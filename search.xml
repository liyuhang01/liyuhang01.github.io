<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构（C语言版）期末复习整理</title>
    <url>/archives/27ff0a3a.html</url>
    <content><![CDATA[<!-- build time:Mon Dec 06 2021 20:32:43 GMT+0800 (中国标准时间) --><p>### 第一章 数据结构概述</p><h4 id="基本概念与术语"><a href="#基本概念与术语" class="headerlink" title="基本概念与术语"></a>基本概念与术语</h4><p>1． <strong>数据</strong>：数据是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被<br>计算机程序所处理的符号的总称。</p><ol start="2"><li><strong>数据元素</strong>：数据元素是数据的基本单位，是数据这个集合中的个体，也称之为元素，结点，顶点记录。<br>（补充：一个数据元素可由若干个 <strong>数据项</strong>组成。数据项是数据的不可分割的最小单位。）<br>3．数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。（有时候也<br>叫做属性。）<br>4． <strong>数据结构</strong>：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>（1）数据的逻辑结构：数据的逻辑结构是指数据元素之间存在的固有逻辑关系，常称为数<br>据结构。<br>数据的逻辑结构是从数据元素之间存在的逻辑关系上描述数据与数据的存储无关，是<br>独立于计算机的。<br>依据数据元素之间的关系，可以把数据的逻辑结构分成以下几种：</li><li><strong>集合</strong>：数据中的数据元素之间除了“同属于一个集合“的关系以外，没有其他关系。</li><li><strong>线性结构</strong>：结构中的数据元素之间存在“一对一“的关系。若结构为非空集合，则除了第<br>一个元素之外，和最后一个元素之外，其他每个元素都只有一个直接前驱和一个直接后继。</li><li><strong>树形结构</strong>：结构中的数据元素之间存在“一对多“的关系。若数据为非空集，则除了第一<br>个元素（根）之外，其它 每个数据元素都只有一个直接前驱，以及多个或零个 直<br>接后继。</li><li><strong>图状结构</strong>：（1）结构中的数据元素存在“多对多”的关系。若结构为非空集，折每个数据可有<br>多个（或零个）直接后继。<br>（2）数据的存储结构：数据元素及其关系在计算机内的表示称为数据的存储结构。<br>想要计算机处理数据，就必须把数据的逻辑结构映射为数据的存储结构。逻辑结构可以映射<br>为以下两种存储结构：<ol><li><strong>顺序存储结构</strong>：把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中，借助元素<br>在存储器中的相对位置来表示数据之间的逻辑关系。</li><li><strong>链式存储结构</strong>：借助指针表达数据元素之间的逻辑关系。不要求逻辑上相邻的数据元素物<br>理位置上也相邻。</li></ol></li><li><strong>时间复杂度分析</strong>：1.常量阶：算法的时间复杂度与问题规模 <strong>n 无关系</strong> T(n)=O(1)<br>2.线性阶：算法的时间复杂度与问题规模 <strong>n 成线性关系</strong> T(n)=O(n)<br>3.平方阶和立方阶：一般为 <strong>循环的嵌套</strong>，循环体最后条件为 i++<br>时间复杂度的大小比较：<br>O(1)&lt; O(log 2 n)&lt; O(n )&lt; O(n log 2 n)&lt; O(n2)&lt; O(n3)&lt; O(2 n )&lt;O(n!)&lt;O(n n)</li></ol><p>6.<strong>算法与程序</strong>：<br>（1）算法的 5 个特性<br>1、 输入：有零个或多个输入<br>2、 输出：有一个或多个输出<br>3、有穷性：要求序列中的指令是有限的；每条指令的执行包含有限的工作量；整个指令序<br>列的执行在有限的时间内结束。（程序与算法的区别在于，程序不需要有有穷性）<br>4、确定性：算法中的每一个步骤都必须是确定的，而不应当含糊、模棱两可。没有歧义。<br>5、可行性：算法中的每一个步骤都应当能被有效的执行，并得到确定的结果。<br>（2）.算法设计的要求：<br>1、正确性（达到预期效果，满足问题需求）<br>2、健壮性（能处理合法数据，也能对不合法的数据作出反应，不会产生不<br>可预期的后果）<br>3、可读性（要求算法易于理解，便于分析）<br>4、可修改可扩展性<br>5、高效率（较好的时空性能 ）<br>补充内容：<br>1、名词解释：数据结构、二元组<br>数据结构就是相互之间存在一种或多种特定关系的数据元素的集合。<br>二元组就是一种用来表示某个数据对象以及各个元素之间关系的有限集合。<br>2、根据数据元素之间关系的不同，数据的逻辑结构可以分为集合、线性结构、树形结构和<br>图状结构四种类型。<br>3、常见的数据存储结构一般有两种类型，它们分别是顺序存储结构、链式存储结构<br>6.在一般情况下，一个算法的时间复杂度是问题规模的函数<br>7.常见时间复杂度有：常数阶 O（1）、线性阶 O（n）、对数阶 O（log 2 n）、平方阶 O(n^2)、<br>指数阶 O(2^n)。通常认为，具有常数阶量级的算法是好算法，而具有指数阶量级的算法是<br>差算法。</p><h3 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h3><p>定义： <strong>线性表</strong>是 n 个数据元素的有限序列。 一个数据元素可由若干个 <strong>数据项</strong>组成。</p><ol><li>顺序表结构<br>线性表的顺序存储是指在内存中 <strong>用地址连续</strong>的一块存储空间顺序存放线性表的各元素，用这<br>种存储形式存储的线性表称为顺序表。</li><li>单链表<br>（1） 链表结点结构<br>线性表中的数据元素可以 <strong>用任意的一组存储单元</strong>来存储，用指针表示逻辑关系逻辑相邻的两<br>元素的存储空间可以是不连续的。<br>（2） 链表操作算法：初始化、插入、输出、删除、遍历<br><strong>初始化：p=(struct student <code>*</code>)malloc(sizeof(struct student));<br>插入： p-&gt;next=head-&gt;next; head-&gt;next=p;<br>输出：printf(“%d”,p-&gt;data);<br>删除：q=p-&gt;next; p-&gt;next = q-&gt;next ; free(q);<br>结点遍历： for(p=head;p;p=p-&gt;next);*</strong><br>补充内容：<br>1、线性表中，第一个元素没有直接前驱，最后一个元素没有直接后驱。<br>2、在一个单链表中，若 p 所指结点是 q 所指结点的前驱结点，则<strong>删除结点 q</strong> 的操作语句为<br><strong>P-&gt;next = q-&gt;next ; free(q);</strong><br>3、在长度为 N 的顺序表中，插入一个新元素平均需要移动表中 N/2 个元素，删除一个元素<br>平均需要移动（N-1）/2 个元素。<br>4、若线性表的主要操作是在最后一个元素之后插入一个元素或删除最后一个元素，则采用<br><strong>顺序表</strong>存储结构最节省运算时间。<br>5、已知顺序表中每个元素占用 3 个存储单元，第 13 个元素的存储地址为 336，则顺序表的<br>首地址为 300。（第 n 个元素的地址即首地址+(n-1)<em>每个元素的存储空间，如 a[12]（第 13<br>个元素）的地址=a[0]+12</em>3）<br>6、设有一带头结点单链表 L，请编写该单链表的初始化，插入、输出和删除函数。（函数名<br>自定义）<br>结点定义：</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype; <span class="comment">//结点数据类型，假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="comment">//结点结构</span></span><br><span class="line">datatype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">//双向链表还应加上*previous</span></span><br><span class="line">&#125; Lnode, * pointer ; <span class="comment">//结点类型,结点指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> pointer lklist; <span class="comment">//单链表类型，即头指针类型</span></span><br><span class="line"><span class="comment">//1.初始化：</span></span><br><span class="line"><span class="function">lklist <span class="title">initlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pointer head;</span><br><span class="line">head=<span class="keyword">new</span> node;<span class="comment">//这是 C++做法</span></span><br><span class="line"><span class="comment">//head=( pointer)malloc(sizeof(Lnode)); 这是 C 语言做法</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>; <span class="comment">//循环链表则是 head-&gt;next=head;</span></span><br><span class="line"><span class="comment">//双向链表应加上 head-&gt;previos=NULL;</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.插入：（C 语言中需要把 head 转化为全局变量才能实现此程序）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(lklist head,datatype x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">pointer q,s;</span><br><span class="line">q=<span class="built_in">get</span>(head,i<span class="number">-1</span>); <span class="comment">//找第 i-1 个点</span></span><br><span class="line"><span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="comment">//无第 i-1 点，即 i&lt;1 或 i&gt;n+1 时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;”非法插入位置!\n”; <span class="comment">//这是 C++做法，即 C 语言中的 printf(“非法插入位置!\n”);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">s=<span class="keyword">new</span> node;<span class="comment">//生成新结点 即 C 语言中的 s=( pointer)malloc(sizeof(Lnode));</span></span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=q-&gt;next; <span class="comment">//新点的后继是原第 i 个点</span></span><br><span class="line">q-&gt;next=s; <span class="comment">//原第 i-1 个点的后继是新点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.删除：（C 语言中需要把 head 转化为全局变量才能实现此程序）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(lklist head,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">pointer p,q;</span><br><span class="line">q=<span class="built_in">get</span>(head,i<span class="number">-1</span>); <span class="comment">//找待删点的直接前趋</span></span><br><span class="line"><span class="keyword">if</span>(q==<span class="literal">NULL</span> || q-&gt;next==<span class="literal">NULL</span>) <span class="comment">//即 i&lt;1 或 i&gt;n 时</span></span><br><span class="line">&#123;<span class="built_in">cout</span>&lt;&lt;”非法删除位置!\n”;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">p=q-&gt;next; <span class="comment">//保存待删点地址</span></span><br><span class="line">q-&gt;next=p-&gt;next; <span class="comment">//修改前趋的后继指针</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//释放结点 即 C 语言中的 free(p);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//删除成功</span></span><br></pre></td></tr></table></figure><ol><li>不带头结点的单链表 head 为空的判定条件是(A )<br>A. head=NULL B. head-&gt;next=NULL C. head-&gt;next=head D. head!=NULL</li><li>带头结点的单链表 head 为空的判定条件是(B )<br>A. head=NULL B. head-&gt;next=NULL C. head-&gt;next=head D. head!=NULL</li><li>在一个单链表中，若 p 所指结点不是最后结点，在 p 之后插入 s 所指结点，则执行(B )<br>A. s-&gt;next=p; p-&gt;next=s; B. s-&gt;next=p-&gt;next; p-&gt;next=s;<br>C. s-&gt;next=p-&gt;next; p=s; D. p-&gt;next=s; s-&gt;next=p;</li><li>在一个单链表中，若删除 p 所指结点的后续结点，则执行(A )<br>A. p-&gt;next=p-&gt;next-&gt;next;<br>B. p=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next;<br>C. p-&gt;next=p-&gt;next<br>D. p=p-&gt;next-&gt;next</li><li>从一个具有 n 个结点的有序单链表中查找其值等于 x 结点时，在查找成功的情况下，需<br>平均比较（B ）个结点。<br>A. n B. n/2 C. (n-1)/2 D. O(n ㏒ 2n)</li><li>给定有 n 个元素的向量，建立一个有序单链表的时间复杂度（B）<br>A.O(1) B.O(n) C.O(n2) D.O(n ㏒ 2n)<br>7.在一个具有 n 个结点的有序单链表中插入一个新结点并仍然有序的时间复杂度是(B)<br>A.O(1) B.O(n) C.O(n2) D.O(n ㏒ 2n)</li><li>在一个单链表中删除 q 所指结点时，应执行如下操作：<br>q=p-&gt;next;<br>p-&gt;next=( p-&gt;next-&gt;next );<br>free(q);//这种题目靠一根指针是没有办法完成的，必须要借助第二根指针。</li><li>在一个单链表中 p 所指结点之后插入一个 s 所指结点时，应执行：<br>s-&gt;next=( p-&gt;next )<br>p-&gt;next=(s)操作。</li><li>对于一个具有 n 个节点的单链表 ,在已知所指结点后插入一个新结点的时间复杂度是(O<br>（1）)；在给定值为 x 的结点后插入一个新结点的时间复杂度是（O(n)）。<br>11.问答题<br>线性表可用顺序表或链表存储。试问：<br>(1) 两种存储表示各有哪些主要优缺点?<br>顺序表的存储效率高，存取速度快。但它的空间大小一经定义，在程序整个运行期间不会发<br>生改变，因此，不易扩充。同时，由于在插入或删除时，为保持原有次序，平均需要移动一<br>半(或近一半)元素，修改效率不高。<br>链接存储表示的存储空间一般在程序的运行过程中动态分配和释放，且只要存储器中还有空<br>间，就不会产生存储溢出的问题。同时在插入和删除时不需要保持数据元素原来的物理顺序，<br>只需要保持原来的逻辑顺序，因此不必移动数据，只需修改它们的链接指针，修改效率较高。<br>但存取表中的数据元素时，只能循链顺序访问，因此存取效率不高。<br>(2) 若表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，<br>这时，应采用哪种存储表示？为什么？<br>应采用顺序存储表示。因为顺序存储表示的存取速度快，但修改效率低。若表的总数基本稳<br>定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，这时采用顺序存储表示<br>较好。</li></ol><h3 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h3><h4 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h4><h5 id="（1）-栈的结构与定义"><a href="#（1）-栈的结构与定义" class="headerlink" title="（1） 栈的结构与定义"></a>（1） 栈的结构与定义</h5><p>定义：限定仅在表尾进行插入或删除操作的线性表。<br>结构：<br>typedef struct list{<br>int listsize; //栈的容量<br>struct list *head; //栈顶指针<br>struct list *base; //栈底指针<br>}</p><h5 id="（2）-顺序栈操作算法："><a href="#（2）-顺序栈操作算法：" class="headerlink" title="（2） 顺序栈操作算法："></a>（2） 顺序栈操作算法：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配初始空间</span></span><br><span class="line">    S-&gt;base = (ElemType *) <span class="built_in">malloc</span>(Stack_Init_Size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S-&gt;base) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top = S-&gt;base; <span class="comment">/// 栈顶与栈底相同</span></span><br><span class="line">    S-&gt;stack_size = Stack_Init_Size; <span class="comment">// 栈的最大长度等于初始长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可</span></span><br><span class="line"><span class="function">Status <span class="title">EmptyStack</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;base == S-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度</span></span><br><span class="line"><span class="function">Status <span class="title">LengthStack</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Status) (S-&gt;top - S-&gt;base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶的元素，参数e用来存放栈顶的元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetTopStack</span><span class="params">(SqStack *S, ElemType *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    *e = *(S-&gt;top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进栈，参数e是要进栈的元素</span></span><br><span class="line"><span class="function">Status <span class="title">PushStack</span><span class="params">(SqStack *S, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若栈的最大长度不会够用时，重新开辟，增大长度</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top - S-&gt;base &gt;= S-&gt;stack_size) &#123;</span><br><span class="line">        S-&gt;base = (ElemType *)<span class="built_in">realloc</span>(S-&gt;base, (S-&gt;stack_size + StackIncrement) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S-&gt;base) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈顶指针为栈底指针加上栈之前的最大长度</span></span><br><span class="line">        S-&gt;top = S-&gt;base + S-&gt;stack_size;</span><br><span class="line">        <span class="comment">// 栈当前的最大长度等于栈之前的最大长度与增加的长度之和</span></span><br><span class="line">        S-&gt;stack_size += StackIncrement;</span><br><span class="line">    &#125;</span><br><span class="line">    *S-&gt;top++ = e; <span class="comment">// 先赋值，后栈顶指针上移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈，参数e用来存放出栈的元素</span></span><br><span class="line"><span class="function">Status <span class="title">PopStack</span><span class="params">(SqStack *S, ElemType *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;base == S-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = *--S-&gt;top; <span class="comment">// 栈顶指针先下移，后赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(S-&gt;base);</span><br><span class="line">    S-&gt;base = S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    S-&gt;stack_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历栈，依次打印每个元素</span></span><br><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    ElemType *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stack is NULL.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = S-&gt;top;</span><br><span class="line">    <span class="comment">// 由栈顶依次向下遍历</span></span><br><span class="line">    <span class="keyword">while</span> (p &gt; S-&gt;base) &#123;</span><br><span class="line">        p--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 链栈操作算法<br>结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">	 ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStack;</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造一个空栈，栈顶指针置为空 </span></span><br><span class="line">	S = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入栈：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S,ElemType e)</span></span>&#123;</span><br><span class="line">	    LinkStack p;<span class="comment">//定义p </span></span><br><span class="line">		p=<span class="keyword">new</span> StackNode;<span class="comment">//生成新结点 </span></span><br><span class="line">		p-&gt;data=e;<span class="comment">//e赋给新结点的数据域 </span></span><br><span class="line">		p-&gt;next=S; <span class="comment">//新结点插入栈顶 </span></span><br><span class="line">		S=p;<span class="comment">//修改栈顶指针为p</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">	LinkStack p;<span class="comment">//定义p </span></span><br><span class="line">	<span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;<span class="comment">//栈空 </span></span><br><span class="line">	e=S-&gt;data;<span class="comment">//将栈顶元素赋给e </span></span><br><span class="line">	p=S;<span class="comment">//p临时保存栈顶元素以备释放 </span></span><br><span class="line">	S=S-&gt;next;<span class="comment">//修改栈顶指针 </span></span><br><span class="line">	<span class="keyword">delete</span> p;<span class="comment">//释放空间 </span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h4><h5 id="（1）-队列的定义"><a href="#（1）-队列的定义" class="headerlink" title="（1） 队列的定义"></a>（1） 队列的定义</h5><p>定义：只允许在表的一端进行插入，而在另一端删除元素。</p><p>补充内容：<br>1、一个栈的入栈序列为“ABCDE”，则以下不可能的出栈序列是（B）<br>A. BCDAE B. EDACB C. BCADE D. AEDCB<br>2、栈的顺序表示中，用 TOP 表示栈顶元素，那么栈空的条件是（D）<br>A. TOP==STACKSIZE B. TOP==1 C. TOP==0 D. TOP==-1<br>3、允许在一端插入，在另一端删除的线性表称为队列。插入的一端为表头，删除的一端为<br>表尾。<br>4、栈的特点是先进后出，队列的特点是先进先出。<br>5、对于栈和队列，无论他们采用顺序存储结构还是链式存储结构，进行插入和删除操作的<br>时间复杂度都是 O(1)（即与已有元素 N 无关）。<br>6、已知链栈 Q，编写函数判断栈空，如果栈空则进行入栈操作，否则出栈并输出。（要求判<br>断栈空、出栈、入栈用函数实现）（详看考点 2）<br>7.出队与取队头元素的区别：出队就是删除对头的数据元素，取队头元素是获取对头的数据<br>元素值，不需要删除。<br>8.链栈与顺序栈相比，比较明显的优点是：（D）<br>A.插入操作比较容易 B.删除操作比较容易<br>C.不会出现栈空的情况 D.不会出现栈满的情况</p><p><strong>考点 1：队列的编程：</strong><br>结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> date;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">QueuePtr front;</span><br><span class="line">QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p>创建：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">InitQueue</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> (Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">EnQueue</span><span class="params">(LinkQueue Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">	 p=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    p-&gt;date=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;<span class="keyword">return</span> (Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">DeQueue</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;QueuePtr p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    e=p-&gt;date;</span><br><span class="line">    Q.front=p-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,e);</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)Q.rear=Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> (Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>考点 2：栈的编程：</strong><br>上述已有具体实现代码</p><h3 id="第四章-串-（不是重点内容）"><a href="#第四章-串-（不是重点内容）" class="headerlink" title="第四章 串 （不是重点内容）"></a>第四章 串 （不是重点内容）</h3><p>1.串是由零个或多个字符组成的有限序列<br>2.串的赋值：x=’abc’;或 x[ ]=’abc’;</p><h3 id="第五章-数组和广义表-（不是重点内容）"><a href="#第五章-数组和广义表-（不是重点内容）" class="headerlink" title="第五章 数组和广义表 （不是重点内容）"></a>第五章 数组和广义表 （不是重点内容）</h3><ol><li>多维数组中某数组元素的 position 求解。一般是给出数组元素的首元素地址和每个元素占<br>用的地址空间并组给出多维数组的维数，然后要求你求出该数组中的某个元素所在的位置。</li><li>明确 <strong>按行存储</strong>和 <strong>按列存储</strong>的区别和联系，并能够按照这两种不同的存储方式求解 1 中类<br>型的题。</li><li>将特殊矩阵中的元素按相应的换算方式存入数组中。这些矩阵包括：对称矩阵，三角矩<br>阵，具有某种特点的稀疏矩阵等。熟悉稀疏矩阵的三种不同存储方式： 三元组，带辅助行向<br>量的二元组， <strong>十字链表</strong>存储。掌握将稀疏矩阵的三元组或二元组向十字链表进行转换的算法。</li></ol><p>补充内容：<br>三元组：<br>结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="keyword">int</span> i,j; <span class="comment">//元素行下标及列下标int e; //元素值&#125;Triple;typedef struct&#123;int mu,nu,tu; //矩阵的行数、列数、非零元素个数Triple data[MAXSIZE+1]; //矩阵包含的三元组表，data[0]未用&#125;TSMatrix;</span></span><br></pre></td></tr></table></figure><p>十字链表：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>&#123;</span><span class="keyword">int</span> i,j; <span class="comment">//元素行下标及列下标int e; //元素值struct OLNode *right,*down; //行的后继以及列的后继&#125; OLNode，*OLink;typedef struct&#123;int mu,nu,tu; //矩阵的行数、列数、非零元素个数OLink *rhead,*chead; //行和列的表头指针组的首地址&#125;CrossList;CrossList Creat（CrossList M）&#123;int m,n,t;scanf(“%d%d%d”,&amp;m,&amp;n,&amp;t);M.mu=m;M.nu=n;M.tu=t;M.rhead=( OLink *)malloc((m+1)*sizeof(OLink)); //开辟行表头指针组M.chead=( OLink *)malloc((n+1)*sizeof(OLink)); //开辟行列头指针组M.rhead[]=M.chead[]=NULL; //初始化…… //接下来就是赋值和入链｝</span></span><br></pre></td></tr></table></figure><h3 id="第六章-树和二叉树"><a href="#第六章-树和二叉树" class="headerlink" title="第六章 树和二叉树"></a>第六章 树和二叉树</h3><h4 id="1．-树"><a href="#1．-树" class="headerlink" title="1． 树"></a>1． 树</h4><p><strong>（1） 树的概念及术语</strong><br><strong>树</strong> ：n（n≥0）个结点的有限集合。当 n＝0 时，称为空树；任意一棵非空树满足以下条件：<br>⑴ 有且仅有一个特定的称为根的结点；<br>⑵ 当 n＞1 时，除根结点之外的其余结点被分成 m（m&gt;0）个互不相交的有限集合<br>T1,T2,… ,Tm，其中每个集合又是一棵树，并称为这个根结点的子树。<br><strong>（2） 结点的度：</strong> 结点所拥有的子树的个数。<br>树的度：树中所有结点的度的最大值。<br><strong>（3） 叶子结点：</strong> 度为 0 的结点，也称为终端结点。<br>分支结点：度不为 0 的结点，也称为非终端结点。<br><strong>（4）孩子、双亲</strong> ：树中某结点的子树的根结点称为这个结点的孩子结点，这个结点称为它<br>孩子结点的双亲结点；<br>兄弟： 具有同一个双亲的孩子结点互称为兄弟。<br><strong>（5）路径：</strong> 如果树的结点序列 n1, n2, …, nk 有如下关系：结点 ni 是 ni+1 的双亲（1&lt;=i&lt;k），<br>则把 n1, n2, …, nk 称为一条由 n1 至 nk 的路径；路径上经过的边的个数称为路径长度。<br><strong>（6）祖先、子孙：</strong> 在树中，如果有一条路径从结点 x 到结点 y，那么 x 就称为 y 的祖先，<br>而 y 称为 x 的子孙。<br><strong>（7）结点所在层数：</strong> 根结点的层数为 1；对其余任何结点，若某结点在第 k 层，则其孩子<br>结点在第 k+1 层。<br>树的深度： 树中所有结点的最大层数，也称高度。<br><strong>（8）层序编号：</strong> 将树中结点按照从上层到下层、同层从左到右的次序依次给他们编以从 1<br>开始的连续自然数。<br><strong>（9）有序树、无序树：</strong> 如果一棵树中结点的各子树从左到右是有次序的，称这棵树为有序<br>树；反之，称为无序树。数据结构中讨论的一般都是有序树<br><strong>（10）</strong> 树通常有前序（根）遍历、后序（根）遍历和层序（次）遍历三种方式（树，<br>不是二叉树，没中序遍历。)</p><h4 id="2．-二叉树"><a href="#2．-二叉树" class="headerlink" title="2． 二叉树"></a>2． 二叉树</h4><p>（1）二叉树的定义：二叉树是 n（n≥0）个结点的有限集合，该集合或者为空集（称为空<br>二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉<br>树组成。</p><p>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在<br>同一层上。<br>（满二叉树的特点：叶子只能出现在最下一层；只有度为 0 和度为 2 的结点。）<br>完全二叉树：对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与<br>同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同。<br>完全二叉树的特点：<br>1.在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树。<br>2.叶子结点只能出现在最下两层，且最下层的叶子结点都集中在二叉树的左部；</p><ol start="3"><li>完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有左孩子。</li><li>深度为 k 的完全二叉树在 k-1 层上一定是满二叉树。</li></ol><p>（2）二叉树的性质：<br>性质 1：二叉树的第 i 层上最多有 2i-1 个结点（i≥1）。<br>性质 2： 一棵深度为 k 的二叉树中，最多有 2k-1 个结点，最少有 k 个结点。深度为 k<br>且具有 2k-1 个结点的二叉树一定是满二叉树<br>性质 3：在一棵二叉树中，如果叶子结点数为 n0，度为 2 的结点数为 n2，则有: n0＝n2<br>＋1。（一个结点的度就是指它放出的射线）<br>性质 4：具有 n 个结点的完全二叉树的深度为 log2n +1。<br>性质 5： 对一棵具有 n 个结点的完全二叉树中从 1 开始按层序编号，则对于任意的序<br>号为 i（1≤i≤n）的结点（简称为结点 i），有：<br>（1）如果 i＞1，则结点 i 的双亲结点的序号为 i/2；如果 i＝1，则结点 i 是根结点，无双<br>亲结点。<br>（2）如果 2i≤n，则结点 i 的左孩子的序号为 2i；如果 2i＞n，则结点 i 无左孩子。<br>（3）如果 2i＋1≤n，则结点 i 的右孩子的序号为 2i＋1；如果 2i＋1＞n，则结点 i 无右孩子。</p><h4 id="3．-二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）"><a href="#3．-二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）" class="headerlink" title="3． 二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）"></a>3． 二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）</h4><p>（1） 先序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XianXu</span><span class="params">(BiTree T)</span></span>&#123;<span class="keyword">if</span>(T)&#123;<span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data); <span class="comment">//先访问XianXu(T-&gt;lchild); //再继续遍历XianXu(T-&gt;rchild);&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>（2） 中序遍历<br>（3） 后序遍历</p><h4 id="4-森林与二叉树的转换"><a href="#4-森林与二叉树的转换" class="headerlink" title="4. 森林与二叉树的转换"></a>4. 森林与二叉树的转换</h4><p>（1）同级以左为亲，即左一结点的右孩子是与它同级的右一结点<br>（2）只认最左路线为亲子路线，即结点的左孩子是它下一级结点的最左的元素</p><h4 id="5-哈夫曼树"><a href="#5-哈夫曼树" class="headerlink" title="5. 哈夫曼树"></a>5. 哈夫曼树</h4><p>(1）哈夫曼树的基本概念：<br>哈夫曼树：给定一组具有确定权值的叶子结点， <strong>带权路径长度</strong>最小的二叉树。<br>(2）哈夫曼树的特点：</p><ol><li>权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。</li><li>只有度为 0（叶子结点）和度为 2（分支结点）的结点，不存在度为 1 的结点.<br>（3）哈夫曼树的构造算法思想及构造过程（森林与 哈夫曼编码）<br>就是求各权值和路径相乘之后叠加的最小值。</li></ol><p>1、已知一棵完全二叉树有 47 个结点，则该二叉树有（C）个叶子结点。<br>A. 6 B. 12 C. 24 D.48<br>解法如下：<br>1+2+4+8+16=31 计算从第一层到 n-1 层的结点个数<br>47-31=16 计算第 n 层的叶子结点个数<br>16-16/2=8 计算第 n-1 层的叶子结点个数<br>所以，叶子结点数=16+8=24 计算第 n 层和第 n-1 层的总叶子结点数<br>2、已知遍历一棵二叉树的前序序列 ABCDEFG 和中序序列 CBEDAFG，那么是下面哪棵树<br>（C ）。<br>C 图如下：<br>A<br>↙　 ↘<br>Ｂ　　　F<br>↙ 　↘ 　　　↘<br>C 　　　D 　　　　 G<br>↙<br>E<br>4、完全二叉树必须满足的条件为: ：一棵具有 n 个结点的二叉树，它的结构与满二叉树的<br>前 n 个结点的的结构相同。<br>5、哈夫曼树不存在度为 1 的结点。<br>6、有 5 个带权结点，其权值分别为 2，5，3，7，11，根据哈夫曼算法构建该树，并计算该<br>树的带权路径长度。（构建哈夫曼树，很简单，从小开始，计算相加，然后把所有叶子结点<br>乘以等级数字然后相加。也即是：带权路径长度=叶结点的权值<em>路径长度）<br>7.试找出分别满足下列条件的所有二叉树：<br>⑴ 前序序列和中序序列相同：*</em>只有右子树**<br>⑵ 中序序列和后序序列相同：<strong>只有左子树</strong><br>⑶ 前序序列和后序序列相同：<strong>只有根，空二叉树</strong></p><h3 id="第七章-图"><a href="#第七章-图" class="headerlink" title="第七章 图"></a>第七章 图</h3><h4 id="1-图的基本概念："><a href="#1-图的基本概念：" class="headerlink" title="1. 图的基本概念："></a>1. 图的基本概念：</h4><p>图的结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。<br>设图有 n 个顶点，则：<br>有 1/2 n(n-1)条边的无向图称为 <strong>完全图</strong><br>有 n（n-1）条弧的有向图称为 <strong>有向完全图</strong><br>元素被多少条弧的箭头所指，它的 <strong>入度</strong>就为多少；反之，出度。<br>第一个顶点和最后一个顶点相同的路径叫做 <strong>回路</strong>或<strong>环</strong> 环<br>顶点不重复出现的路径叫 <strong>简单路径</strong><br>若图中任意两个顶点之间存在路径（不一定是直接相连），则称作 <strong>连通图</strong>。</p><h4 id="2-邻接矩阵："><a href="#2-邻接矩阵：" class="headerlink" title="2. 邻接矩阵："></a>2. 邻接矩阵：</h4><p>．<br>W i,j &lt;V i ，V j &gt; ∈VR<br>邻接矩阵的定义： A[i][j]={<br>0 即 VR 中不存在 &lt;V i ，V j &gt;时</p><h4 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h4><p>（1）深度优先遍历<br>步骤：1.从任意顶点开始访问。<br>2.访问后把该元素对应的访问标志赋值为 1 表示已访问该数据元素<br>3.寻找与其有关未被访问的所有邻接顶点，并从该顶点开始进行访问</p><ol start="4"><li>重复 2、3 步骤直到该连通图的所有顶点均已访问完毕<br>（2）广度优先遍历<br>步骤：1.从任意顶点开始访问。<br>2.访问后把该元素对应的访问标志赋值为 1 表示已访问该数据元素<br>3.寻找与其有关未被访问的邻接顶点，并按顺序入列直到所有邻接顶点均<br>已访问完毕<br>4.把最先入列的顶点出列，以它为顶点开始访问</li><li>重复 2、3、4 步骤直到该连通图的所有顶点均已访问完毕</li></ol><h3 id="第八九十章"><a href="#第八九十章" class="headerlink" title="第八九十章"></a>第八九十章</h3><p>查找表<br>是由同一类型的数据元素（或记录）构成的集合<br>对查找表的操作有：<br>（1） 查询某个“特定的”数据元素是否在查找表中；<br>（2） 检索某个“特定的”数据元素的各种属性<br>（3） 在查找表中插入一个数据元素；<br>（4） 从查找表中删去某个特定元素<br>静态查找表<br>只进行前两种“查找”操作的查找表为静态查找表<br>动态查找表<br>若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某<br>个数据元素，则成为动态查找表<br>排序<br>其功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。</p><h3 id="既然都看到这了，码字不易，记得点赞收藏哦！！！"><a href="#既然都看到这了，码字不易，记得点赞收藏哦！！！" class="headerlink" title="既然都看到这了，码字不易，记得点赞收藏哦！！！"></a>既然都看到这了，码字不易，记得点赞收藏哦！！！</h3><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构（C语言版）期末复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现双向巡回链表</title>
    <url>/archives/c49a2ddd.html</url>
    <content><![CDATA[<!-- build time:Wed Dec 01 2021 19:37:41 GMT+0800 (中国标准时间) --><p>主要利用双向链表实现26个英文字母的循环输出</p><p>例如输入3，输入结果：</p><p>DEFGHIJKLMNOPQRSTUVWXYZABC</p><p>输入-3，则输出结果:</p><p>XYZABCDEFGHIJKLMNOPQRSTUVW</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*Linked;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(Linked *L)</span></span>&#123;<span class="comment">//初始化链表</span></span><br><span class="line">    Node *p,*q;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    *L = (Linked)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//生成一个指向头结点的指针</span></span><br><span class="line">    <span class="keyword">if</span>(!(*L))&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = (*L)-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">     p = (*L);<span class="comment">//p节点指向头结点，然后p在指向q，q在往后移动</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;<span class="comment">//添加26个英文字母</span></span><br><span class="line">        q = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//生成一个新节点，往里赋值，然后p指向q，</span></span><br><span class="line">                                         <span class="comment">//在生成新节点，以此循环</span></span><br><span class="line">        <span class="keyword">if</span>(!q)&#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;data = <span class="string">'A'</span>+i;</span><br><span class="line">        q-&gt;prior = p;</span><br><span class="line">        q-&gt;next = p-&gt;next;<span class="comment">//把q的next置为null</span></span><br><span class="line">        p-&gt;next = q;</span><br><span class="line"> </span><br><span class="line">        p=q;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//实现巡回的主要步骤</span></span><br><span class="line"> </span><br><span class="line">     p-&gt;next = (*L)-&gt;next; <span class="comment">//此时p，q都在最指的是最后一个节点，使p/q指向头结点的下一个节点</span></span><br><span class="line">     (*L)-&gt;next-&gt;prior=p;<span class="comment">//然后头结点的下一个节点在指回p/q。</span></span><br><span class="line">     (*L) = p;<span class="comment">//头结点在指向p/q</span></span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Casear</span><span class="params">(Linked *L,<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//打印输出链表</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            (*L) = (*L)-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(--i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line"> </span><br><span class="line">            (*L) = (*L)-&gt;prior;</span><br><span class="line">        &#125;<span class="keyword">while</span>(++i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linked L;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    InitList(&amp;L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个整数：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    Casear(&amp;L,n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言实现双向巡回链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的基本操作</title>
    <url>/archives/65ba9d2a.html</url>
    <content><![CDATA[<!-- build time:Mon Nov 29 2021 22:05:47 GMT+0800 (中国标准时间) --><h2 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h2><h3 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h3><p>通过该实验，让学生掌握二叉树的相关基本概念，理解二叉树的链式存储，掌握二叉树的几种遍历算法，并通过该实验理解递归的含义，掌握C语言编写递归函数的方法和注意事项。</p><h3 id="2-实验主要仪器、设备和材料等"><a href="#2-实验主要仪器、设备和材料等" class="headerlink" title="2.实验主要仪器、设备和材料等"></a>2.实验主要仪器、设备和材料等</h3><p>硬件：PC机</p><p>软件：Dev-C++、VC 6.0或CodeBlocks等。</p><h3 id="3-实验内容（包括实验原理和操作步骤）"><a href="#3-实验内容（包括实验原理和操作步骤）" class="headerlink" title="3.实验内容（包括实验原理和操作步骤）"></a>3.实验内容（包括实验原理和操作步骤）</h3><ol><li><p>按照先序遍历的顺序创建一个二叉链表；</p></li><li><p>对已建立的二叉树实现先序遍历、中序遍历、后序遍历、求深度、求结点数量等操作。</p></li><li><p>最好用菜单形式对应各个操作，使其编程一个完整的小软件。</p><p><strong>测试用例：</strong></p><p><img data-src="../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/01.png" alt></p></li></ol><ul><li><p>创建</p></li><li><p>输入：ABC##DE#G##F###</p></li><li><p>该输入对应的树如上图所示</p></li><li><p>先序 屏幕输出 A B C D E G F</p></li><li><p>中序 屏幕输出 C B E G D F A</p></li><li><p>后序 屏幕输出 C G E F D B A</p></li><li><p>深度 屏幕显示 深度为5</p></li><li><p>结点数量 屏幕显示 结点数量为7</p></li><li><p>销毁 销毁后的二叉树再进行遍历等操作会提示二叉树未创建。</p></li></ul><h3 id="参考界面："><a href="#参考界面：" class="headerlink" title="参考界面："></a>参考界面：</h3><p><img data-src="../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/02.png" alt></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct BitNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct BitNode *lchild,*rchild;</span><br><span class="line">&#125;BitNode,*BiTree;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建二叉树</span><br><span class="line">void CreateBiTree(BiTree &amp;T)&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    if(ch&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">         T&#x3D;NULL;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        T&#x3D;new BitNode;</span><br><span class="line">        T-&gt;data&#x3D;ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);</span><br><span class="line">        CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;先序遍历</span><br><span class="line">void PreOrderTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">void InOrderTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;后序遍历</span><br><span class="line">void PostTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line"></span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求二叉树的深度</span><br><span class="line">int Depth(BiTree T)&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    if(T&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        m&#x3D;Depth(T-&gt;lchild);</span><br><span class="line">        n&#x3D;Depth(T-&gt;rchild);</span><br><span class="line">        if(m&gt;n)&#123;</span><br><span class="line">            return (m+1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (n+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;统计二叉树节点的数量</span><br><span class="line">int NodeCount(BiTree T)&#123;</span><br><span class="line">    if(T&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;销毁二叉树</span><br><span class="line">void DestroyBitree(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        DestroyBitree(T-&gt;lchild);</span><br><span class="line">        DestroyBitree(T-&gt;rchild);</span><br><span class="line">        free(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int code;</span><br><span class="line">	int flag&#x3D;0;</span><br><span class="line">	BiTree T&#x3D;NULL;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">	system(&quot;cls&quot;);</span><br><span class="line">	printf(&quot;**********************************************************\n&quot;);</span><br><span class="line">	printf(&quot;****                  ****系统菜单****                ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  1.创建二叉树                  *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  2.先序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  3.中序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  4.后序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  5.求二叉树的深度              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  6.求二叉树的节点数量          *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  7.销毁二叉树                  *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  8.退出                        *    ****\n&quot;);</span><br><span class="line">	printf(&quot;**********************************************************\n&quot;);</span><br><span class="line">		printf(&quot;请输入操作代码:&quot;);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;code);</span><br><span class="line">		getchar();</span><br><span class="line">		switch(code)</span><br><span class="line">		&#123;</span><br><span class="line">		case 1:</span><br><span class="line">			&#123;</span><br><span class="line">			    printf(&quot;请输入二叉树元素（‘#’表示为空）\n&quot;);</span><br><span class="line">			    CreateBiTree(T);</span><br><span class="line">                printf(&quot;二叉树创建成功\n&quot;);</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		case 2:</span><br><span class="line">			&#123;</span><br><span class="line">                if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;先序遍历后:\n&quot;);</span><br><span class="line">                PreOrderTraverse(T);</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">		    &#125;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		case 3:</span><br><span class="line">                if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;中序遍历后:\n&quot;);</span><br><span class="line">                    InOrderTraverse(T);</span><br><span class="line">                    printf(&quot;\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">		    break;</span><br><span class="line">		case 4:</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;先序遍历后:\n&quot;);</span><br><span class="line">                PostTraverse(T);</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		    break;</span><br><span class="line">		case 5:</span><br><span class="line">		    int deep;</span><br><span class="line">            if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                deep&#x3D;Depth(T);</span><br><span class="line">                printf(&quot;二叉树的深度为：%d\n&quot;,deep);</span><br><span class="line">		    &#125;</span><br><span class="line">			break;</span><br><span class="line">		case 6:</span><br><span class="line">		    int num;</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                num&#x3D;NodeCount(T);</span><br><span class="line">                printf(&quot;二叉树的节点数量为：%d\n&quot;,num);</span><br><span class="line">		    &#125;</span><br><span class="line">		    break;</span><br><span class="line">		case 7:</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                DestroyBitree(T);</span><br><span class="line">                flag&#x3D;0;</span><br><span class="line">                printf(&quot;二叉树已被销毁\n&quot;,num);</span><br><span class="line">		    &#125;</span><br><span class="line">		    break;</span><br><span class="line">		case 8:</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;程序结束!\n&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		default:printf(&quot;数据无效，请重新输入!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		system(&quot;pause&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>实现二叉树的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>不规则动词总结表</title>
    <url>/archives/c07a60bb.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><p>​</p><h1 id="英语不规则动词总结表"><a href="#英语不规则动词总结表" class="headerlink" title="英语不规则动词总结表"></a><center>英语不规则动词总结表</center></h1><h2 id="一、AAA型（原形→原形→原形）"><a href="#一、AAA型（原形→原形→原形）" class="headerlink" title="一、AAA型（原形→原形→原形）"></a>一、AAA型（原形→原形→原形）</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>read</td><td>read</td><td>read</td><td>读</td></tr><tr><td>cut</td><td>cut</td><td>cut</td><td>切，割</td></tr><tr><td>let</td><td>let</td><td>let</td><td>让</td></tr><tr><td>put</td><td>put</td><td>put</td><td>放</td></tr><tr><td>cost</td><td>cost</td><td>cost</td><td>花费，值</td></tr><tr><td>hit</td><td>hit</td><td>hit</td><td>撞，击</td></tr><tr><td>set</td><td>set</td><td>set</td><td>安排，安置</td></tr><tr><td>hurt</td><td>hurt</td><td>hurt</td><td>使…伤痛</td></tr><tr><td>bet</td><td>bet</td><td>bet</td><td>赌博，打赌</td></tr><tr><td>cast</td><td>cast</td><td>cast</td><td>抛</td></tr></tbody></table><h2 id="二、ABA型（原形→过去式→原形）"><a href="#二、ABA型（原形→过去式→原形）" class="headerlink" title="二、ABA型（原形→过去式→原形）"></a>二、ABA型（原形→过去式→原形）</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>become</td><td>became</td><td>become</td><td>成为</td></tr><tr><td>come</td><td>came</td><td>come</td><td>来</td></tr><tr><td>run</td><td>ran</td><td>run</td><td>跑</td></tr></tbody></table><h2 id="三、ABC型"><a href="#三、ABC型" class="headerlink" title="三、ABC型"></a>三、ABC型</h2><h3 id="1-ow-→ew-→own"><a href="#1-ow-→ew-→own" class="headerlink" title="1. ow →ew →own"></a>1. ow →ew →own</h3><table><thead><tr><th align="left">原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td align="left">blow</td><td>blew</td><td>blown</td><td>吹</td></tr><tr><td align="left">draw</td><td>drew</td><td>drawn</td><td>画</td></tr><tr><td align="left">grow</td><td>grew</td><td>grown</td><td>生长</td></tr><tr><td align="left">know</td><td>knew</td><td>known</td><td>知道</td></tr><tr><td align="left">throw</td><td>threw</td><td>thrown</td><td>扔</td></tr></tbody></table><h3 id="2-i→a-→u"><a href="#2-i→a-→u" class="headerlink" title="2. i→a →u"></a>2. i→a →u</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>begin</td><td>began</td><td>begun</td><td>开始</td></tr><tr><td>drink</td><td>drank</td><td>drunk</td><td>喝</td></tr><tr><td>sing</td><td>sang</td><td>sung</td><td>唱</td></tr><tr><td>swim</td><td>swam</td><td>swum</td><td>游泳</td></tr><tr><td>ring</td><td>rang</td><td>rung</td><td>打电话</td></tr></tbody></table><h3 id="3-原形→过去式→过去式-e-n"><a href="#3-原形→过去式→过去式-e-n" class="headerlink" title="3. 原形→过去式→过去式+(e)n"></a>3. 原形→过去式→过去式+(e)n</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>wear</td><td>wore</td><td>worn</td><td>穿</td></tr><tr><td>forget</td><td>forgot</td><td>forgotten</td><td>忘记</td></tr><tr><td>speak</td><td>spoke</td><td>spoken</td><td>说</td></tr><tr><td>freeze</td><td>froze</td><td>frozen</td><td>冻</td></tr><tr><td>choose</td><td>chose</td><td>chosen</td><td>选择</td></tr></tbody></table><h3 id="4-原形→过去式→原形-e-n"><a href="#4-原形→过去式→原形-e-n" class="headerlink" title="4. 原形→过去式→原形+(e)n"></a>4. 原形→过去式→原形+(e)n</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>eat</td><td>ate</td><td>eaten</td><td>吃</td></tr><tr><td>forbid</td><td>forbade</td><td>forbidden</td><td>禁止</td></tr><tr><td>give</td><td>gave</td><td>given</td><td>给</td></tr><tr><td>ride</td><td>rode</td><td>ridden</td><td>骑</td></tr><tr><td>see</td><td>saw</td><td>seen</td><td>看见</td></tr><tr><td>write</td><td>wrote</td><td>written</td><td>写</td></tr><tr><td>fall</td><td>fell</td><td>fallen</td><td>落下</td></tr><tr><td>break</td><td>broke</td><td>broken</td><td>打破，折断</td></tr><tr><td>forgive</td><td>forgave</td><td>forgiven</td><td>原谅；宽恕</td></tr><tr><td>drive</td><td>drove</td><td>driven</td><td>驾驶</td></tr><tr><td>mistake</td><td>mistook</td><td>mistaken</td><td>误解</td></tr><tr><td>rise</td><td>rose</td><td>risen</td><td>上升</td></tr><tr><td>shake</td><td>shook</td><td>shaken</td><td>摇</td></tr></tbody></table><h3 id="5-无规律"><a href="#5-无规律" class="headerlink" title="5. 无规律"></a>5. 无规律</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>am/is</td><td>was</td><td>been</td><td>是</td></tr><tr><td>are</td><td>were</td><td>been</td><td>是</td></tr><tr><td>do</td><td>did</td><td>done</td><td>做</td></tr><tr><td>go</td><td>went</td><td>gone</td><td>走</td></tr><tr><td>take</td><td>took</td><td>taken</td><td>拿</td></tr></tbody></table><h2 id="四、ABB型"><a href="#四、ABB型" class="headerlink" title="四、ABB型"></a>四、ABB型</h2><h3 id="1-原形→ought-→ought"><a href="#1-原形→ought-→ought" class="headerlink" title="1. 原形→ought →ought"></a>1. 原形→ought →ought</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>bring</td><td>brought</td><td>brought</td><td>带来</td></tr><tr><td>buy</td><td>bought</td><td>bought</td><td>买</td></tr><tr><td>fight</td><td>fought</td><td>fought</td><td>打架</td></tr><tr><td>think</td><td>thought</td><td>thought</td><td>思考</td></tr><tr><td>seek</td><td>sought</td><td>sought</td><td>寻求</td></tr></tbody></table><h3 id="2-原形→aught-→aught"><a href="#2-原形→aught-→aught" class="headerlink" title="2. 原形→aught →aught"></a>2. 原形→aught →aught</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>catch</td><td>caught</td><td>caught</td><td>捉,抓</td></tr><tr><td>teach</td><td>taught</td><td>taught</td><td>教</td></tr></tbody></table><h3 id="3-变其中一个元音字母"><a href="#3-变其中一个元音字母" class="headerlink" title="3.变其中一个元音字母"></a>3.变其中一个元音字母</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>feed</td><td>fed</td><td>fed</td><td>喂</td></tr><tr><td>meet</td><td>met</td><td>met</td><td>遇见</td></tr><tr><td>get</td><td>got</td><td>got</td><td>得到</td></tr><tr><td>hold</td><td>held</td><td>held</td><td>拥有</td></tr><tr><td>babysit</td><td>babysat</td><td>babysat</td><td>临时照看</td></tr><tr><td>sit</td><td>sat</td><td>sat</td><td>坐</td></tr><tr><td>win</td><td>won</td><td>won</td><td>赢</td></tr><tr><td>find</td><td>found</td><td>found</td><td>发现</td></tr><tr><td>bend</td><td>bent</td><td>bent</td><td>使弯曲</td></tr><tr><td>dig</td><td>dug</td><td>dug</td><td>挖</td></tr><tr><td>lead</td><td>led</td><td>led</td><td>引导</td></tr><tr><td>sell</td><td>sold</td><td>sold</td><td>卖</td></tr><tr><td>retell</td><td>retold</td><td>retold</td><td>复述</td></tr></tbody></table><h3 id="4-原形→□t→□t"><a href="#4-原形→□t→□t" class="headerlink" title="4. 原形→□t→□t"></a>4. 原形→□t→□t</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>feel</td><td>felt</td><td>felt</td><td>感到</td></tr><tr><td>keep</td><td>kept</td><td>kept</td><td>保持</td></tr><tr><td>leave</td><td>left</td><td>left</td><td>离开</td></tr><tr><td>sleep</td><td>slept</td><td>slept</td><td>睡</td></tr><tr><td>sweep</td><td>swept</td><td>swept</td><td>扫</td></tr><tr><td>smell</td><td>smelt</td><td>smelt</td><td>闻；发出气味</td></tr></tbody></table><h3 id="5-变其中一个辅音字母"><a href="#5-变其中一个辅音字母" class="headerlink" title="5.变其中一个辅音字母"></a>5.变其中一个辅音字母</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>build</td><td>built</td><td>built</td><td>建造</td></tr><tr><td>hear</td><td>heard</td><td>heard</td><td>听见</td></tr><tr><td>make</td><td>made</td><td>made</td><td>制造</td></tr><tr><td>mean</td><td>meant</td><td>meant</td><td>意思</td></tr><tr><td>send</td><td>sent</td><td>sent</td><td>送,寄</td></tr><tr><td>spend</td><td>spent</td><td>spent</td><td>花费</td></tr><tr><td>deal</td><td>dealt</td><td>dealt</td><td>处理</td></tr><tr><td>rebuild</td><td>rebuilt</td><td>rebuilt</td><td>重建</td></tr><tr><td>lend</td><td>lent</td><td>lent</td><td>借贷</td></tr></tbody></table><h3 id="6-辅音字母和元音字母都变"><a href="#6-辅音字母和元音字母都变" class="headerlink" title="6.辅音字母和元音字母都变"></a>6.辅音字母和元音字母都变</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>have</td><td>had</td><td>had</td><td>有,吃</td></tr><tr><td>lay</td><td>lain</td><td>lain</td><td>放</td></tr><tr><td>lose</td><td>lost</td><td>lost</td><td>丢失</td></tr><tr><td>pay</td><td>paid</td><td>paid</td><td>付钱</td></tr><tr><td>say</td><td>said</td><td>said</td><td>说</td></tr><tr><td>sell</td><td>sold</td><td>sold</td><td>卖</td></tr><tr><td>tell</td><td>told</td><td>told</td><td>告诉</td></tr><tr><td>stand</td><td>stood</td><td>stood</td><td>站</td></tr><tr><td>misunderstand</td><td>misunderstood</td><td>misunderstood</td><td>误解</td></tr><tr><td>shoot</td><td>shot</td><td>shot</td><td>放炮；开枪</td></tr><tr><td>understand</td><td>understood</td><td>understood</td><td>理解</td></tr></tbody></table><h2 id="五、AAB型"><a href="#五、AAB型" class="headerlink" title="五、AAB型"></a>五、AAB型</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th align="center">汉语意思</th></tr></thead><tbody><tr><td>beat</td><td>beat</td><td>beaten</td><td align="center">打败</td></tr></tbody></table><h2 id="六、有两种形式"><a href="#六、有两种形式" class="headerlink" title="六、有两种形式"></a>六、有两种形式</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>bear</td><td>bore</td><td>born</td><td>生</td></tr><tr><td>bore</td><td>borne</td><td></td><td></td></tr><tr><td>hang</td><td>hanged</td><td>hanged</td><td>吊死</td></tr><tr><td>hung</td><td>hung</td><td>挂</td><td></td></tr><tr><td>learn</td><td>learned</td><td>learned</td><td>学</td></tr><tr><td>learnt</td><td>learnt</td><td></td><td></td></tr><tr><td>lie</td><td>lied</td><td>lied</td><td>说谎</td></tr><tr><td>lay</td><td>lain</td><td>躺</td><td></td></tr><tr><td>show</td><td>showed</td><td>showed</td><td>给……看</td></tr><tr><td>showed</td><td>shown</td><td></td><td></td></tr><tr><td>spell</td><td>spelled</td><td>spelled</td><td>拼写</td></tr><tr><td>spelt</td><td>spelt</td><td></td><td></td></tr><tr><td>burn</td><td>burned</td><td>burned</td><td>烧</td></tr><tr><td>burnt</td><td>burnt</td><td></td><td></td></tr><tr><td>smell</td><td>smelled</td><td>smelled</td><td>闻</td></tr><tr><td>smelt</td><td>smelt</td><td></td><td></td></tr><tr><td>shine</td><td>shined</td><td>shined</td><td>照耀</td></tr><tr><td>shone</td><td>shone</td><td></td><td></td></tr><tr><td>dream</td><td>dreamed</td><td>dreamed</td><td>做梦</td></tr><tr><td>dreamt</td><td>dreamt</td><td></td><td></td></tr><tr><td>wake</td><td>waked</td><td>waked</td><td>醒</td></tr><tr><td>woke</td><td>woken</td><td></td><td></td></tr><tr><td>hide</td><td>hid</td><td>hid</td><td>躲藏</td></tr><tr><td>hid</td><td>hidden</td><td></td><td></td></tr><tr><td>bite</td><td>bit</td><td>bit</td><td>咬</td></tr><tr><td>bit</td><td>bitten</td><td></td><td></td></tr><tr><td>light</td><td>lighted</td><td>iighted</td><td>点着</td></tr><tr><td>lit</td><td>lit</td><td></td><td></td></tr><tr><td>prove</td><td>proved</td><td>proved</td><td>证明</td></tr><tr><td>proved</td><td>proven</td><td></td><td></td></tr><tr><td>quit</td><td>quit</td><td>quit</td><td>放弃</td></tr><tr><td>quited</td><td>quited</td><td></td><td></td></tr><tr><td>rid</td><td>rid</td><td>rid</td><td>免除；去掉</td></tr><tr><td>ridded</td><td>ridded</td><td></td><td></td></tr><tr><td>saw</td><td>sawed</td><td>sawed</td><td>锯</td></tr><tr><td>sawed</td><td>sawn</td><td></td><td></td></tr><tr><td>sew</td><td>sewed</td><td>sewed</td><td>缝纫</td></tr><tr><td>sewed</td><td>sown</td><td></td><td></td></tr><tr><td>shine</td><td>shone</td><td>shone</td><td>发光；闪亮</td></tr><tr><td>shined</td><td>shined</td><td></td><td></td></tr><tr><td>sink</td><td>sank</td><td>sunk</td><td>下沉</td></tr><tr><td>sank</td><td>sunken</td><td></td><td></td></tr><tr><td>sow</td><td>sowed</td><td>sowed</td><td>种植</td></tr><tr><td>sowed</td><td>sown</td><td></td><td></td></tr><tr><td>spit</td><td>spat</td><td>spat</td><td>吐</td></tr><tr><td>spit</td><td>spit</td><td></td><td></td></tr><tr><td>spring</td><td>sprang</td><td>sprung</td><td>跳跃</td></tr><tr><td>sprung</td><td>sprung</td><td></td><td></td></tr><tr><td>wet</td><td>wet</td><td>wet</td><td>浸湿；弄湿</td></tr><tr><td>wetted</td><td>wetted</td><td></td><td></td></tr></tbody></table><h2 id="七、情态动词"><a href="#七、情态动词" class="headerlink" title="七、情态动词"></a>七、情态动词</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>can</td><td>could</td><td>∕</td><td>能</td></tr><tr><td>may</td><td>might</td><td>∕</td><td>也许</td></tr><tr><td>must</td><td>∕</td><td>∕</td><td>必须</td></tr><tr><td>shall</td><td>should</td><td>∕</td><td>将要</td></tr><tr><td>will</td><td>would</td><td>∕</td><td>会</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>不规则动词总结表</tag>
      </tags>
  </entry>
  <entry>
    <title>高数公式</title>
    <url>/archives/29c7973.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h1 id="高数数学所有公式总结"><a href="#高数数学所有公式总结" class="headerlink" title="高数数学所有公式总结"></a>高数数学所有公式总结</h1><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_1.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_2.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_3.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_4.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_5.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_6.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_7.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_8.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_9.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_10.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_11.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_12.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_13.png" alt></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>高数公式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中$event的用法——如何获取当前兄弟元素，子元素，父元素</title>
    <url>/archives/378703a1.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tempalte&gt;</span><br><span class="line"></span><br><span class="line">   &lt;button @click = “getEvent($event)”&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">      methods:&#123;</span><br><span class="line"></span><br><span class="line">         getEvent(e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// e.target 是你当前点击的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// e.currentTarget 是你绑定事件的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           #获得点击元素的前一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.innerHTML</span><br><span class="line"></span><br><span class="line">           #获得点击元素的第一个子元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.firstElementChild</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的下一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.nextElementSibling</span><br><span class="line"></span><br><span class="line">           # 获得点击元素中id为string的元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getElementById(<span class="string">"string"</span>)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的string属性</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getAttributeNode(<span class="string">'string'</span>)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的父级元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.parentElement</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的前一个元素的第一个子元素的HTML值</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.firstElementChild.innerHTML</span><br><span class="line"></span><br><span class="line">         &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Jsp中的session</title>
    <url>/archives/fdcf16bb.html</url>
    <content><![CDATA[<!-- build time:Mon Dec 06 2021 20:32:43 GMT+0800 (中国标准时间) --><p>Jsp中的session</p><p>1.什么是session:<br>当用户打开浏览器，访问某个网站的时候，服务器就会在服务器的内存为该浏览器分配一个内存空间，该空间被这个浏览器独占，这个空间就是session空间。<br>该空间中的数据默认存在时间为30min,可以修改(session.setMaxInactiveInterval(int seconds))</p><p>2.session可以用来做什么？<br>（1）可以用作网上商城的购物车<br>（2）保存登录用户的信息<br>（3）将某些数据放在session中，供同一用户的各个页面使用（共享数据）<br>（4）防止用户非法登录到某个页面</p><p>3.session的使用：<br>（1）得到session<br>servlet中：HttpSession hs = request.getSession(true);<br>jsp中:session是一个内置对象，可以直接使用<br>(2)向session添加属性：<br>servlet中：hs.setAttribute(String name,Object value)<br>jsp中：session.setAttribute(String name,Object value)<br>(3)从session得到某个属性：<br>servlet中：hs.getAttribute(String name)<br>jsp中：session.getAttribute(String name)<br>(4)从session中删除某个属性：<br>servlet中:hs.removeAttribute(String name)<br>jsp中:hs.removeAttribute(String name)</p><p>4.session注意事项：<br>（1）session默认存在时间是30分钟，在tomcat的web.xml中的<session-out>可以修改<br>（2）上述默认时间指的是“发呆时间”，不是累计时间，就是不访问它的时间超过30分钟就会被回收，期间访问了它的话这个时间就会重新计算<br>（3）当某个浏览器访问服务器时，服务器会给它一个唯一的session id,通过id来区分不痛的浏览器<br>（4）因为session要占用服务器内存，因此在迫不得已的情况下才使用（一般使用：保存用户信息，保存购物车）</session-out></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>解决eclipse端口被占用</title>
    <url>/archives/969da7de.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h4 id="解决eclipse端口被占用"><a href="#解决eclipse端口被占用" class="headerlink" title="解决eclipse端口被占用"></a>解决eclipse端口被占用</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-801d15d118d7c3e5.png" alt="5640239-801d15d118d7c3e5.png"></p><p>问题如图所示，在eclipse中开启tomcat服务器时报错：端口已被占用。</p><p>这是因为在tomcat开启的状态下，eclipse异常关闭，导致tomcat一直占用端口。<br>解决办法如下：</p><p>1： 输入命令netstat -ano|findstr “8080”，查看8080端口是否被占用，且得到了进程号“13384”；</p><p>2： 再输入命令tasklist|findstr “13384”，得到进程映像名javaw.exe；</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-779a4d67255f5cfb.png" alt="5640239-779a4d67255f5cfb.png"></p><p>3： 启动任务管理器，结束javaw.exe进程；</p><ul><li>用鼠标打开任务管理器，首先鼠标放在电脑最下边靠右边的任务栏上，点击右键</li></ul><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-16874fe86025821b.png" alt="5640239-16874fe86025821b.png"></p><p>选择启动任务管理器，用鼠标左键单击，就打开了任务管理器</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-a6d975126589654c.jpg" alt="5640239-a6d975126589654c.jpg"></p><p>找到13384所对应的程序，结束任务</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-390417a76c06c5c7.png" alt="5640239-390417a76c06c5c7.png"></p><ol start="4"><li>最后再输入命令netstat -ano|findstr “8080”，查看8080端口是否被还占用</li></ol><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-dbccc1732c77b015.png" alt="5640239-dbccc1732c77b015.png"></p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>eclipse端口被占用解决办法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue获取节点总结</title>
    <url>/archives/a8f7bb1e.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="vue获取各个节点的方式"><a href="#vue获取各个节点的方式" class="headerlink" title="vue获取各个节点的方式"></a>vue获取各个节点的方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tempalte&gt;</span><br><span class="line"></span><br><span class="line">   &lt;button @click &#x3D; “getEvent($event)”&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   export default &#123;</span><br><span class="line"></span><br><span class="line">      methods:&#123;</span><br><span class="line"></span><br><span class="line">         getEvent(e) &#123;</span><br><span class="line"></span><br><span class="line">            console.log(e)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; e.target 是你当前点击的元素</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; e.currentTarget 是你绑定事件的元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           #获得点击元素的前一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.innerHTML</span><br><span class="line"></span><br><span class="line">           #获得点击元素的第一个子元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.firstElementChild</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的下一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.nextElementSibling</span><br><span class="line"></span><br><span class="line">           # 获得点击元素中id为string的元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getElementById(&quot;string&quot;)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的string属性</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getAttributeNode(&#39;string&#39;)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的父级元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.parentElement</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的前一个元素的第一个子元素的HTML值</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.firstElementChild.innerHTML</span><br><span class="line"></span><br><span class="line">         &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue获取节点总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库总结</title>
    <url>/archives/3086330.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-如何在命令行配置MYSQL数据库"><a href="#1-如何在命令行配置MYSQL数据库" class="headerlink" title="1.如何在命令行配置MYSQL数据库"></a>1.如何在命令行配置MYSQL数据库</h3><p>1）找到MYSQL安装目录的bin目录</p><p>2）放置到path环境变量中</p><h3 id="2-启动停止MYSQL"><a href="#2-启动停止MYSQL" class="headerlink" title="2.启动停止MYSQL"></a>2.启动停止MYSQL</h3><p>启动： netstarmysqla 停止：mysql net stop mysqla</p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>binary,int,float,double,char,varchar,text,datetime</p><h3 id="4-添加数据库"><a href="#4-添加数据库" class="headerlink" title="4.添加数据库"></a>4.添加数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="5-查看数据库"><a href="#5-查看数据库" class="headerlink" title="5.查看数据库"></a>5.查看数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">show create database;</span><br></pre></td></tr></table></figure><h3 id="6-删除数据"><a href="#6-删除数据" class="headerlink" title="6.删除数据"></a>6.删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="7-使用数据库前需要先打开数据表所在的数据库"><a href="#7-使用数据库前需要先打开数据表所在的数据库" class="headerlink" title="7.使用数据库前需要先打开数据表所在的数据库"></a>7.使用数据库前需要先打开数据表所在的数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><h3 id="8-创建表"><a href="#8-创建表" class="headerlink" title="8.创建表"></a>8.创建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名(字段1 类型（长度）,[约束]，.....);</span><br></pre></td></tr></table></figure><h3 id="9-查询当前数据库下有哪些表"><a href="#9-查询当前数据库下有哪些表" class="headerlink" title="9.查询当前数据库下有哪些表"></a>9.查询当前数据库下有哪些表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables</span><br></pre></td></tr></table></figure><h3 id="10-查询表结构"><a href="#10-查询表结构" class="headerlink" title="10.查询表结构"></a>10.查询表结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sesc student</span><br></pre></td></tr></table></figure><h3 id="11-数据库备份与还原"><a href="#11-数据库备份与还原" class="headerlink" title="11.数据库备份与还原"></a>11.数据库备份与还原</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump-uroot-p first-db&gt;C:123456.sql</span><br></pre></td></tr></table></figure><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>1.数据库没有大小写之分</p><p>2.关键词大写，自定义的小写<br>3.修改表内容的关键词</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 （动作）</span><br><span class="line">改表名 动作 rename 新表名</span><br><span class="line">改字段类型 动作 modify 字段名 新类型</span><br><span class="line">改字段名称 动作 change 旧名称 新名称 新类型</span><br><span class="line">增加字段 动作 add 新增字段名 新增字段类型</span><br><span class="line">删除字段 动作 drop 字段名</span><br><span class="line">删除表 drop table 表名;</span><br><span class="line">删除数据库 drop database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="1、数据完整性"><a href="#1、数据完整性" class="headerlink" title="1、数据完整性"></a>1、数据完整性</h3><p>主键约束 primary key 特点是非空且唯一<br>两种写法，直接写在字段后，或者写在创建语句最后 primary key（字段名）<br>联合主键 写在创建语句最后 primary key(字段 1，字段 2)</p><h3 id="2、设置字段自增长-auto-increment"><a href="#2、设置字段自增长-auto-increment" class="headerlink" title="2、设置字段自增长 auto_increment"></a>2、设置字段自增长 auto_increment</h3><p>数据表只有一个自增长列，为主键列</p><h3 id="3、外键约束-foreign-key"><a href="#3、外键约束-foreign-key" class="headerlink" title="3、外键约束 foreign key"></a>3、外键约束 foreign key</h3><p>写在创建语句最后 foreign key (从表字段名) references 主表名<br>（主表字段名）</p><h3 id="4、非空约束-not-null"><a href="#4、非空约束-not-null" class="headerlink" title="4、非空约束 not null"></a>4、非空约束 not null</h3><h3 id="5、默认约束-default-值，注意字符串，需外加单引号"><a href="#5、默认约束-default-值，注意字符串，需外加单引号" class="headerlink" title="5、默认约束 default 值，注意字符串，需外加单引号"></a>5、默认约束 default 值，注意字符串，需外加单引号</h3><h3 id="6、唯一约束-unique"><a href="#6、唯一约束-unique" class="headerlink" title="6、唯一约束 unique"></a>6、唯一约束 unique</h3><p>主键约束和唯一约束的区别，主键无意义，唯一约束可以为 null<br>设计规范<br>1NF（第一范式）保证数据列的原子性<br>家庭住址 可分为省 市 县 具体地址<br>2NF 保证每列都和主键相关（唯一主键，联合主键不满足）<br>学号 姓名 课程 教材 教材内容<br>1 张三 数据库 mysql XXXXX（1 千字）<br>1 张三 java java<br>2 李四 数据库 mysql XXXXX（1 千字）<br>3 王五 数据库 mysql XXXXX（1 千字）<br>数据冗余 更新异常 插入异常 删除异常</p><p>3NF 保证每列都和主键直接相关<br>学号 姓名 班级 辅导员编号 辅导员姓名 辅导员家庭住址</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="数据库的增删改操作"><a href="#数据库的增删改操作" class="headerlink" title="数据库的增删改操作"></a>数据库的增删改操作</h3><h3 id="1、插入数据"><a href="#1、插入数据" class="headerlink" title="1、插入数据"></a>1、插入数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名（列 1，列 2，。。。） values（值 1，值 2，。。。）；</span><br><span class="line">查询数据</span><br><span class="line">select * from 表名;</span><br></pre></td></tr></table></figure><h3 id="2、into-关键字可以省略"><a href="#2、into-关键字可以省略" class="headerlink" title="2、into 关键字可以省略"></a>2、into 关键字可以省略</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简写形式 insert 表名（列 1，列 2，。。。） values（值 1，值 2，。。。）；</span><br></pre></td></tr></table></figure><h3 id="3、全列插入可省略列明"><a href="#3、全列插入可省略列明" class="headerlink" title="3、全列插入可省略列明"></a>3、全列插入可省略列明</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简写形式 insert 表名 values（值 1，值 2，。。。）；</span><br></pre></td></tr></table></figure><h3 id="4、自增列和默认列可省略"><a href="#4、自增列和默认列可省略" class="headerlink" title="4、自增列和默认列可省略"></a>4、自增列和默认列可省略</h3><p>注意：自增列只增不减<br>除非：alter table 表名 set auto_increment=值;<br>或者 truncate table 表名; 清空表，自增从 1 开始记数</p><h3 id="5、一次插入多行"><a href="#5、一次插入多行" class="headerlink" title="5、一次插入多行"></a>5、一次插入多行</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 表名（列 1，列 2，。。。） values（值 1，值 2，。。。），（值 1，</span><br><span class="line">值 2，。。。），。。。。；</span><br></pre></td></tr></table></figure><h3 id="6、比较运算"><a href="#6、比较运算" class="headerlink" title="6、比较运算"></a>6、比较运算</h3><p>大于&gt;=大于等于&lt;小于&lt;=小于等于 =等于 !=或&lt;&gt;不等于</p><p>is null 为空 is not null 非空 in 在某个范围 not in 不在某个范<br>围 like 模糊查询 between and 在某个范围</p><h3 id="7、逻辑运算"><a href="#7、逻辑运算" class="headerlink" title="7、逻辑运算"></a>7、逻辑运算</h3><p>not 非 and 并且 or 或者</p><h3 id="8、修改数据"><a href="#8、修改数据" class="headerlink" title="8、修改数据"></a>8、修改数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 列名 1&#x3D;值 1，列名 2&#x3D;值 2… where 条件;</span><br></pre></td></tr></table></figure><p>如果没有 where 全更新</p><h3 id="9、删除数据"><a href="#9、删除数据" class="headerlink" title="9、删除数据"></a>9、删除数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 条件;</span><br></pre></td></tr></table></figure><p>注意删除数据不更改自增列的值</p><h3 id="10、清空数据"><a href="#10、清空数据" class="headerlink" title="10、清空数据"></a>10、清空数据</h3><p>truncate table 表名功能同 delete from 表名<br>但是<br>1&gt;Delete 无法修改自增列，truncate 重置自增列<br>2&gt;Delete 可以删除外键约束，truncate 只能清空数据，无法删除外<br>键约束<br>3&gt;Delete 可以通过备份和日子恢复，truncate 无法恢复</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><strong>注意：</strong><br>1、数据库没有双引号，字符一定要用单引号包括<br>2、字段名不用引号，单引号包括的一定是字符<br>``(数字键 1 左边的键)</p><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>select 字段 1、字段 2… from 表名 where 条件 order by 字段 1、<br>字段 2.. limit 数字 1,数字 2;<br>*是通配符，表示所有字段<br>使用 as 为字段重命名</p><h3 id="3、where-查询条件"><a href="#3、where-查询条件" class="headerlink" title="3、where 查询条件"></a>3、where 查询条件</h3><h3 id="4、distinct-查询不重复字段"><a href="#4、distinct-查询不重复字段" class="headerlink" title="4、distinct 查询不重复字段"></a>4、distinct 查询不重复字段</h3><h3 id="5、limit-n-m"><a href="#5、limit-n-m" class="headerlink" title="5、limit n,m"></a>5、limit n,m</h3><p>从 n+1 行开始取，取 m 行，行数从 0 开始<br>limit n,取前 n 行</p><h3 id="6、order-by-字段-1"><a href="#6、order-by-字段-1" class="headerlink" title="6、order by 字段 1"></a>6、order by 字段 1</h3><p>通过字段 1 将表从小到大排列<br>order by 字段 1 desc<br>order by 字段 1,字段 2<br>先按照字段 1 排列，在字段 1 相同的情况下按照字段 2 排列</p><p>成绩表，姓名，成绩<br>查询一下第 3 到 6 的女学生姓名<br>select 姓名 from 成绩表 where 性别=’女’ order by 成绩 desc<br>limit 2,4;<br>MySQL 函数<br>concat(‘今天’,’晴天’) 拼接字符串<br>length(‘hello world’) 计算长度，一个字符，符号，数字占 1 位，<br>一个汉字占 3 位<br>upper(‘abcd’) 转成大写<br>ltrim(‘ abc’) 清除左侧空格<br>rtrim(‘abc ‘) 清除右侧空格<br>trim(‘ abc ‘) 清除两侧空格<br>replace(‘abccd’,’c’,’x’) 将 abccd 中的所有 c 替换成 x<br>strcmp(‘a’,’b’) 比较字符串大小<br>substring(‘abcdefg’,3,3) 取子串，从第 3 个开始取，取 3 个<br>数学函数<br>rand(); 取 0~1 的随机小数，取不到 0 和 1<br>ceil();向上取整<br>floor(); 向下取整</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="模糊查询和分组查询"><a href="#模糊查询和分组查询" class="headerlink" title="模糊查询和分组查询"></a>模糊查询和分组查询</h3><p>模糊查询使用 like 关键字， _代表一个字符 ，%代表任意长度的字<br>符（0 也是任意长度）<br>between and 关键字，表示大于等于第一个数，小于等于第二个数<br>select * from stuinfo where age between 18 and 20;where age &gt;=18 and age&lt;=20;<br>聚合函数<br>求和 sum，平均 avg，最大 max，最小 min，个数 count(<em>)使用聚合函数只有一行结果分组查询group by 写在 where 后面，order by 前面select \</em> from stuinfo group by age;只有聚合函数和被分组的列有意义使用 having 对分组结果进行条件查询，写在 group by 后面P43 count(*)和 count(列名)<br>count(列名)，如果列里面是 null 的，不计入总数</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>数据库有3中连接方式（MySQL有），其他数据库如（Oracle，SQL Server）<br>有 4 中包括全连接</p><h3 id="1、内连接"><a href="#1、内连接" class="headerlink" title="1、内连接"></a>1、内连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1，表 2 WHERE 条件</span><br></pre></td></tr></table></figure><p>另一种写法</p><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 INNER JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="2、左连接"><a href="#2、左连接" class="headerlink" title="2、左连接"></a>2、左连接</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 LEFT JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="3、右连接"><a href="#3、右连接" class="headerlink" title="3、右连接"></a>3、右连接</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 RIGHT JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="4、全连接"><a href="#4、全连接" class="headerlink" title="4、全连接"></a>4、全连接</h3><p>先左连接再右连接</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA面向对象总结</title>
    <url>/archives/4732fab1.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="第二章：类和对象的创建"><a href="#第二章：类和对象的创建" class="headerlink" title="第二章：类和对象的创建"></a>第二章：类和对象的创建</h2><p>概念：面向对象就是把一个项目，一个事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。</p><p>好处：面相对象更接近实物的本质，提高代码的复用更具有扩展性。</p><p>如何使用：通常是创建类的对象再给属性赋值。</p><p>构造方法：构造方法的名称和类名相同，没有返回值类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO g&#x3D;new GO();</span><br></pre></td></tr></table></figure><p>构造方法的重载：方法名相同，参数列表不同，这是构造方法的重载。</p><p>如果一个类中包含了两个或两个以上的方法，他们方法名相同，方法参数个数或者参数类型不同，则称该方法被重载了，这个过程是方法重载。</p><p>Static：可以用来修饰属性，方法和代码块，静态方法中不能使用this和super关键字。</p><h2 id="第三章：封装"><a href="#第三章：封装" class="headerlink" title="第三章：封装"></a>第三章：封装</h2><p>概念：封装指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>好处：提高了安全性 提高了复用性 提高了实现细节</p><p>注意事项：类的属性中均用private来修饰 定义geter和seter方法</p><h2 id="第四章：继承"><a href="#第四章：继承" class="headerlink" title="第四章：继承"></a>第四章：继承</h2><p>概念：比如FeiGe快递系统中有三个实体类Person（人），Courier（快递员）,Customer（客户）类，Courier,Customer都属于（派生类）Person，所以都继承（extends）自Person类。</p><p>好处：提高了代码的重用性 提高了代码的扩展性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：class 类名 extends父接口&#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;属性定义</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;方法定义&#125;</span><br></pre></td></tr></table></figure><p>注意事项：1.子类继承父类所以的属性和方法，只不过只能调用非Private属性和方法2.java中的继承只支持单继承，意思是一个子类只能继承一个父类，但是允许多层继承</p><p>继承中的构造方法：调用父类中的构造方法，</p><p>需用到关键字super super指代父类</p><p>重写的概念：在继承的关系中。子类会自动继承父类中定义的方法，但有时子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：void 方法名（）&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意事项：子类重写父类的方法时，不能使用比父类中被重写的方法更严格的访问权限，重写方法和被重写方法必须具有相同的方法名，相同的参数列表和相同的返回值类型，重写方法的访问修饰符必须大于被重写方法的访问修饰符，否则就不能被称为方法的重写。</p><p>异常的处理：在程序执行代码的时候万一发生了异常，程序会按照预定的处理方法对异常进行处理，异常处理完毕之后，程序继续运行。</p><h3 id="语法：5个关键字-try-catch-finally-throw-throws"><a href="#语法：5个关键字-try-catch-finally-throw-throws" class="headerlink" title="语法：5个关键字 try catch finally throw throws"></a>语法：5个关键字 try catch finally throw throws</h3><p>常见的异常类型</p><p>Exception 异常层次的根类 ArithmeticException 算术错误情形，如以零作除数</p><p>ArrayIndexOutOfBoundsException 数组下标越界</p><p>NullPointerException空指针异常</p><p>ClassNotFoundException不能加载所需的类</p><p>InputMismatchException得到的数据类型与实际输入的类型不匹配</p><p>llegalArgumentException方法接收到非法参数</p><p>ClassCastException对象强制类型转换出错</p><p>NumberFormatException数字格式转换异常，如把“abc”转换成数字</p><h2 id="第五章：多态"><a href="#第五章：多态" class="headerlink" title="第五章：多态"></a>第五章：多态</h2><p>概念：指允许不同类的对象对同一消息做出响应即同同一消息可以根据发送对象的不同而采用多种不同的行为方式。</p><p>好处：可替换性 可扩充性 接口性 灵活性 简化性</p><p>多态的使用：</p><p>子类向父类转换称为向上转型</p><h3 id="向上转型：-lt-父类型-gt-lt-引用变量名-gt-new-lt-子类型-gt-（）；"><a href="#向上转型：-lt-父类型-gt-lt-引用变量名-gt-new-lt-子类型-gt-（）；" class="headerlink" title="向上转型：&lt;父类型&gt;&lt;引用变量名&gt;=new&lt;子类型&gt;（）；"></a>向上转型：&lt;父类型&gt;&lt;引用变量名&gt;=new&lt;子类型&gt;（）；</h3><p>将一个指向子类对象的父类引用赋给一个子类的引用，即将父类类型转换子类类型，称为向下转型，此时必须进行强制类型转换。</p><h3 id="向下转型：-lt-子类型-gt-lt-引用变量名-gt-（-lt-子类型-gt-）-lt-父类型的引用变量-gt-；"><a href="#向下转型：-lt-子类型-gt-lt-引用变量名-gt-（-lt-子类型-gt-）-lt-父类型的引用变量-gt-；" class="headerlink" title="向下转型：&lt;子类型&gt;&lt;引用变量名&gt;=（&lt;子类型&gt;）&lt;父类型的引用变量&gt;；"></a>向下转型：&lt;子类型&gt;&lt;引用变量名&gt;=（&lt;子类型&gt;）&lt;父类型的引用变量&gt;；</h3><p>运算符：instanceof 进行类型的判断</p><p>Try-catch-finally 如果try中的所有语句正常执行完毕那么finally块就会被执行</p><p>多重catch 一段代码会出现多种异常这时可以在try语句后写多个catch语句块</p><h2 id="第六章：抽象"><a href="#第六章：抽象" class="headerlink" title="第六章：抽象"></a>第六章：抽象</h2><p>概念：如果一个类没有足够的信息去描述一个具体的对象那我们就称之为抽象类</p><p>语法：public abstract class类名{}</p><p>作用：抽象类是用来继承的比普通类更通用</p><p>抽象方法：abstract修饰没有方法体之声明返回的数据类型 方法名称和所需要的参数</p><p>语法 ：public abstract 返回值类型 方法名（参数列表）；</p><p>注意事项：包含抽象方法的类一定是抽象类 抽象类中不一定都是抽象方法 构造方法不能生命为抽象方法 abstract不能与private static final native 并列修饰同一个方法</p><p>Final 修饰类 被final修饰过的类不能被继承 因为不能被继承所以此类中所有方法都是final修饰 该类如果不需要有子类不需要被扩展类的方法不允许被重写就用final修饰该类</p><p>Throws通过try-catch捕获处理异常</p><h2 id="第七章：接口"><a href="#第七章：接口" class="headerlink" title="第七章：接口"></a>第七章：接口</h2><p>概述：在软件中接口是一种规范和标准他们可以约束类的行为是一些方法特征的集合但是没有方法的实现</p><p>语法：</p><p>【修饰符】interface接口名extends父接口1，父接口2……{//常量定义//方法定义}</p><p>Class类名extends父类名implements接口1，接口2….{//类成员}</p><p>Run（）；方法提供服务</p><p>接口是一种能力接口是一种约定</p><p>抛出异常：throw 除系统自动抛出异常可以用throw自动抛出异常</p><p>Throw在程序中抛出异常throws在方法内抛出异常</p><p>第八章：集合框架</p><p>集合框架使用方便的接口和类都在java.util包中</p><p>集合框架的特点：</p><p>长度 数组长度是固定的集合长度是可变的</p><p>存储对象 数组可以存储基本的数据类型，也可以存储对象的引用 集合只能用于存储对象的引用</p><p>对象类型 数组必须是相同类型的数据 对象可以是不同类型</p><p>接口区别：</p><p>Collection接口存储组 不唯一(允许重复)、 无序的对象。<br>Set接口继承Collection接口，存储-组唯一(不允许重复)、 无序的对象。<br>List接口继承Collection接口，存储组不唯-(允许重复)、 有序(以元素插入的次序来放置无素，不会重新排列)的对象<br>Map接口存储组成对的键 值对象，提供key(键)到value(值)的映射。Map中的key不要求有序，不允许重复。value 同样不要求有序，但允许重复。</p><p>List接口：</p><p>实现List接口的常用类有ArayList和Lnkedist.它们都可以容纳所有类型的对象，包括nll允许重复，并且都保证元素的存储顺序。<br>ArrayList和LinkedList的大致区别:<br>arraylist是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构对于随机访问get和set, ArrayList 优于LinkedList, 因为LinkedList要移动指针。<br>对于新增和删除操作add和remove, LinkedList 比较占优势，因为ArrayList要移动数据。</p><p>list接口定义中的格各种常用方法</p><p>boolean add(Object o)在列表末尾顺序添加元素，起始索引位置从0开始<br>int size()返回列表中的元素个数<br>void add(int index,Objecto)在指定的索 引位置添加元素，原索引位置及其后面的元素依次后移<br>注意:新添加元素的索引位置必须介于0和列表中元素个数之间</p><p>0bject get(int index)返回指定索引位置处的元素<br>注意:取出的元素是Object类型，使用前需要进行强制类型转换<br>boolean contains(Object o)判断列表中是否存在指定元素<br>boolean remove(Object o)从列表中删除元素<br>Object remove(int index)从列表中删除指定位置元素，起始索引位置从0开始</p><p>Linkedlist的一些特殊用法<br>void addFirst(Object o)在列表的首部添加元素<br>void addLast(Object o)在列表的末尾添加元素<br>Object getFirst( )返回列表中的第一” 个元素<br>Object getLast( )返回列表中的最后一个元素<br>Object removeFirst( )删除并返回列表中的第一个元素</p><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Hashset的优点就是各方面都很快但数据是无序的</p><p>Threeset优点是有序而且可以按照升序方式进行排序，但是其他各方面不突出</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Object put （object key，object value）以“键一值对”的方式进行存储<br>如果武图添加重复的<br>键，那么最后加入的“键-值对”将替换掉原先的“键一道<br>对”<br>Object get (Object key)根据键返回相关联的值，若不存在指定的键，则返回null</p><p>Object remove (Object key)删除指定的键映射的“键一值对”<br>int size()返回元素个数<br>Set keySet()返回键的集合<br>Collection values( )返回值的集合<br>boolean containsKey (Object key)若存在指定的键映射的“键值对”，则返回true<br>boolean isEmpty( )若不存在键一值映射关系，则返回true<br>void clear()从此映射中移除所有映射关系<br>泛型集合：list ArrayList</p><p>ArrayL ist&lt;0bject&gt; list=new ArrayL ist&lt;0bject&gt;() ;</p><p>list. add (0);</p><p>list. add(99.9);</p><p>list. add(false);</p><p>使用泛型集合在创建集合对象时指定集合中元素的类型，从集合中取出元素时无须进行类型强制转换，并且如果把非指定类型对象放入集合，会出现编译错误。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言实现双向巡回链表</title>
    <url>/archives/c49a2ddd.html</url>
    <content><![CDATA[<!-- build time:Wed Dec 01 2021 19:35:04 GMT+0800 (中国标准时间) --><p>主要利用双向链表实现26个英文字母的循环输出</p><p>例如输入3，输入结果：</p><p>DEFGHIJKLMNOPQRSTUVWXYZABC</p><p>输入-3，则输出结果:</p><p>XYZABCDEFGHIJKLMNOPQRSTUVW</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*Linked;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(Linked *L)</span></span>&#123;<span class="comment">//初始化链表</span></span><br><span class="line">    Node *p,*q;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    *L = (Linked)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//生成一个指向头结点的指针</span></span><br><span class="line">    <span class="keyword">if</span>(!(*L))&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = (*L)-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">     p = (*L);<span class="comment">//p节点指向头结点，然后p在指向q，q在往后移动</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;<span class="comment">//添加26个英文字母</span></span><br><span class="line">        q = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//生成一个新节点，往里赋值，然后p指向q，</span></span><br><span class="line">                                         <span class="comment">//在生成新节点，以此循环</span></span><br><span class="line">        <span class="keyword">if</span>(!q)&#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;data = <span class="string">'A'</span>+i;</span><br><span class="line">        q-&gt;prior = p;</span><br><span class="line">        q-&gt;next = p-&gt;next;<span class="comment">//把q的next置为null</span></span><br><span class="line">        p-&gt;next = q;</span><br><span class="line"> </span><br><span class="line">        p=q;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//实现巡回的主要步骤</span></span><br><span class="line"> </span><br><span class="line">     p-&gt;next = (*L)-&gt;next; <span class="comment">//此时p，q都在最指的是最后一个节点，使p/q指向头结点的下一个节点</span></span><br><span class="line">     (*L)-&gt;next-&gt;prior=p;<span class="comment">//然后头结点的下一个节点在指回p/q。</span></span><br><span class="line">     (*L) = p;<span class="comment">//头结点在指向p/q</span></span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Casear</span><span class="params">(Linked *L,<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//打印输出链表</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            (*L) = (*L)-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(--i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line"> </span><br><span class="line">            (*L) = (*L)-&gt;prior;</span><br><span class="line">        &#125;<span class="keyword">while</span>(++i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linked L;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    InitList(&amp;L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个整数：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    Casear(&amp;L,n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言实现双向巡回链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的基本操作</title>
    <url>/archives/65ba9d2a.html</url>
    <content><![CDATA[<!-- build time:Mon Nov 29 2021 22:05:47 GMT+0800 (中国标准时间) --><h2 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h2><h3 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h3><p>通过该实验，让学生掌握二叉树的相关基本概念，理解二叉树的链式存储，掌握二叉树的几种遍历算法，并通过该实验理解递归的含义，掌握C语言编写递归函数的方法和注意事项。</p><h3 id="2-实验主要仪器、设备和材料等"><a href="#2-实验主要仪器、设备和材料等" class="headerlink" title="2.实验主要仪器、设备和材料等"></a>2.实验主要仪器、设备和材料等</h3><p>硬件：PC机</p><p>软件：Dev-C++、VC 6.0或CodeBlocks等。</p><h3 id="3-实验内容（包括实验原理和操作步骤）"><a href="#3-实验内容（包括实验原理和操作步骤）" class="headerlink" title="3.实验内容（包括实验原理和操作步骤）"></a>3.实验内容（包括实验原理和操作步骤）</h3><ol><li><p>按照先序遍历的顺序创建一个二叉链表；</p></li><li><p>对已建立的二叉树实现先序遍历、中序遍历、后序遍历、求深度、求结点数量等操作。</p></li><li><p>最好用菜单形式对应各个操作，使其编程一个完整的小软件。</p><p><strong>测试用例：</strong></p><p><img data-src="../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/01.png" alt></p></li></ol><ul><li><p>创建</p></li><li><p>输入：ABC##DE#G##F###</p></li><li><p>该输入对应的树如上图所示</p></li><li><p>先序 屏幕输出 A B C D E G F</p></li><li><p>中序 屏幕输出 C B E G D F A</p></li><li><p>后序 屏幕输出 C G E F D B A</p></li><li><p>深度 屏幕显示 深度为5</p></li><li><p>结点数量 屏幕显示 结点数量为7</p></li><li><p>销毁 销毁后的二叉树再进行遍历等操作会提示二叉树未创建。</p></li></ul><h3 id="参考界面："><a href="#参考界面：" class="headerlink" title="参考界面："></a>参考界面：</h3><p><img data-src="../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/02.png" alt></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct BitNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct BitNode *lchild,*rchild;</span><br><span class="line">&#125;BitNode,*BiTree;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建二叉树</span><br><span class="line">void CreateBiTree(BiTree &amp;T)&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    if(ch&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">         T&#x3D;NULL;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        T&#x3D;new BitNode;</span><br><span class="line">        T-&gt;data&#x3D;ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);</span><br><span class="line">        CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;先序遍历</span><br><span class="line">void PreOrderTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">void InOrderTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;后序遍历</span><br><span class="line">void PostTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line"></span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求二叉树的深度</span><br><span class="line">int Depth(BiTree T)&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    if(T&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        m&#x3D;Depth(T-&gt;lchild);</span><br><span class="line">        n&#x3D;Depth(T-&gt;rchild);</span><br><span class="line">        if(m&gt;n)&#123;</span><br><span class="line">            return (m+1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (n+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;统计二叉树节点的数量</span><br><span class="line">int NodeCount(BiTree T)&#123;</span><br><span class="line">    if(T&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;销毁二叉树</span><br><span class="line">void DestroyBitree(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        DestroyBitree(T-&gt;lchild);</span><br><span class="line">        DestroyBitree(T-&gt;rchild);</span><br><span class="line">        free(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int code;</span><br><span class="line">	int flag&#x3D;0;</span><br><span class="line">	BiTree T&#x3D;NULL;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">	system(&quot;cls&quot;);</span><br><span class="line">	printf(&quot;**********************************************************\n&quot;);</span><br><span class="line">	printf(&quot;****                  ****系统菜单****                ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  1.创建二叉树                  *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  2.先序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  3.中序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  4.后序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  5.求二叉树的深度              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  6.求二叉树的节点数量          *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  7.销毁二叉树                  *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  8.退出                        *    ****\n&quot;);</span><br><span class="line">	printf(&quot;**********************************************************\n&quot;);</span><br><span class="line">		printf(&quot;请输入操作代码:&quot;);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;code);</span><br><span class="line">		getchar();</span><br><span class="line">		switch(code)</span><br><span class="line">		&#123;</span><br><span class="line">		case 1:</span><br><span class="line">			&#123;</span><br><span class="line">			    printf(&quot;请输入二叉树元素（‘#’表示为空）\n&quot;);</span><br><span class="line">			    CreateBiTree(T);</span><br><span class="line">                printf(&quot;二叉树创建成功\n&quot;);</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		case 2:</span><br><span class="line">			&#123;</span><br><span class="line">                if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;先序遍历后:\n&quot;);</span><br><span class="line">                PreOrderTraverse(T);</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">		    &#125;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		case 3:</span><br><span class="line">                if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;中序遍历后:\n&quot;);</span><br><span class="line">                    InOrderTraverse(T);</span><br><span class="line">                    printf(&quot;\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">		    break;</span><br><span class="line">		case 4:</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;先序遍历后:\n&quot;);</span><br><span class="line">                PostTraverse(T);</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		    break;</span><br><span class="line">		case 5:</span><br><span class="line">		    int deep;</span><br><span class="line">            if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                deep&#x3D;Depth(T);</span><br><span class="line">                printf(&quot;二叉树的深度为：%d\n&quot;,deep);</span><br><span class="line">		    &#125;</span><br><span class="line">			break;</span><br><span class="line">		case 6:</span><br><span class="line">		    int num;</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                num&#x3D;NodeCount(T);</span><br><span class="line">                printf(&quot;二叉树的节点数量为：%d\n&quot;,num);</span><br><span class="line">		    &#125;</span><br><span class="line">		    break;</span><br><span class="line">		case 7:</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                DestroyBitree(T);</span><br><span class="line">                flag&#x3D;0;</span><br><span class="line">                printf(&quot;二叉树已被销毁\n&quot;,num);</span><br><span class="line">		    &#125;</span><br><span class="line">		    break;</span><br><span class="line">		case 8:</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;程序结束!\n&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		default:printf(&quot;数据无效，请重新输入!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		system(&quot;pause&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>实现二叉树的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>不规则动词总结表</title>
    <url>/archives/c07a60bb.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><p>​</p><h1 id="英语不规则动词总结表"><a href="#英语不规则动词总结表" class="headerlink" title="英语不规则动词总结表"></a><center>英语不规则动词总结表</center></h1><h2 id="一、AAA型（原形→原形→原形）"><a href="#一、AAA型（原形→原形→原形）" class="headerlink" title="一、AAA型（原形→原形→原形）"></a>一、AAA型（原形→原形→原形）</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>read</td><td>read</td><td>read</td><td>读</td></tr><tr><td>cut</td><td>cut</td><td>cut</td><td>切，割</td></tr><tr><td>let</td><td>let</td><td>let</td><td>让</td></tr><tr><td>put</td><td>put</td><td>put</td><td>放</td></tr><tr><td>cost</td><td>cost</td><td>cost</td><td>花费，值</td></tr><tr><td>hit</td><td>hit</td><td>hit</td><td>撞，击</td></tr><tr><td>set</td><td>set</td><td>set</td><td>安排，安置</td></tr><tr><td>hurt</td><td>hurt</td><td>hurt</td><td>使…伤痛</td></tr><tr><td>bet</td><td>bet</td><td>bet</td><td>赌博，打赌</td></tr><tr><td>cast</td><td>cast</td><td>cast</td><td>抛</td></tr></tbody></table><h2 id="二、ABA型（原形→过去式→原形）"><a href="#二、ABA型（原形→过去式→原形）" class="headerlink" title="二、ABA型（原形→过去式→原形）"></a>二、ABA型（原形→过去式→原形）</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>become</td><td>became</td><td>become</td><td>成为</td></tr><tr><td>come</td><td>came</td><td>come</td><td>来</td></tr><tr><td>run</td><td>ran</td><td>run</td><td>跑</td></tr></tbody></table><h2 id="三、ABC型"><a href="#三、ABC型" class="headerlink" title="三、ABC型"></a>三、ABC型</h2><h3 id="1-ow-→ew-→own"><a href="#1-ow-→ew-→own" class="headerlink" title="1. ow →ew →own"></a>1. ow →ew →own</h3><table><thead><tr><th align="left">原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td align="left">blow</td><td>blew</td><td>blown</td><td>吹</td></tr><tr><td align="left">draw</td><td>drew</td><td>drawn</td><td>画</td></tr><tr><td align="left">grow</td><td>grew</td><td>grown</td><td>生长</td></tr><tr><td align="left">know</td><td>knew</td><td>known</td><td>知道</td></tr><tr><td align="left">throw</td><td>threw</td><td>thrown</td><td>扔</td></tr></tbody></table><h3 id="2-i→a-→u"><a href="#2-i→a-→u" class="headerlink" title="2. i→a →u"></a>2. i→a →u</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>begin</td><td>began</td><td>begun</td><td>开始</td></tr><tr><td>drink</td><td>drank</td><td>drunk</td><td>喝</td></tr><tr><td>sing</td><td>sang</td><td>sung</td><td>唱</td></tr><tr><td>swim</td><td>swam</td><td>swum</td><td>游泳</td></tr><tr><td>ring</td><td>rang</td><td>rung</td><td>打电话</td></tr></tbody></table><h3 id="3-原形→过去式→过去式-e-n"><a href="#3-原形→过去式→过去式-e-n" class="headerlink" title="3. 原形→过去式→过去式+(e)n"></a>3. 原形→过去式→过去式+(e)n</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>wear</td><td>wore</td><td>worn</td><td>穿</td></tr><tr><td>forget</td><td>forgot</td><td>forgotten</td><td>忘记</td></tr><tr><td>speak</td><td>spoke</td><td>spoken</td><td>说</td></tr><tr><td>freeze</td><td>froze</td><td>frozen</td><td>冻</td></tr><tr><td>choose</td><td>chose</td><td>chosen</td><td>选择</td></tr></tbody></table><h3 id="4-原形→过去式→原形-e-n"><a href="#4-原形→过去式→原形-e-n" class="headerlink" title="4. 原形→过去式→原形+(e)n"></a>4. 原形→过去式→原形+(e)n</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>eat</td><td>ate</td><td>eaten</td><td>吃</td></tr><tr><td>forbid</td><td>forbade</td><td>forbidden</td><td>禁止</td></tr><tr><td>give</td><td>gave</td><td>given</td><td>给</td></tr><tr><td>ride</td><td>rode</td><td>ridden</td><td>骑</td></tr><tr><td>see</td><td>saw</td><td>seen</td><td>看见</td></tr><tr><td>write</td><td>wrote</td><td>written</td><td>写</td></tr><tr><td>fall</td><td>fell</td><td>fallen</td><td>落下</td></tr><tr><td>break</td><td>broke</td><td>broken</td><td>打破，折断</td></tr><tr><td>forgive</td><td>forgave</td><td>forgiven</td><td>原谅；宽恕</td></tr><tr><td>drive</td><td>drove</td><td>driven</td><td>驾驶</td></tr><tr><td>mistake</td><td>mistook</td><td>mistaken</td><td>误解</td></tr><tr><td>rise</td><td>rose</td><td>risen</td><td>上升</td></tr><tr><td>shake</td><td>shook</td><td>shaken</td><td>摇</td></tr></tbody></table><h3 id="5-无规律"><a href="#5-无规律" class="headerlink" title="5. 无规律"></a>5. 无规律</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>am/is</td><td>was</td><td>been</td><td>是</td></tr><tr><td>are</td><td>were</td><td>been</td><td>是</td></tr><tr><td>do</td><td>did</td><td>done</td><td>做</td></tr><tr><td>go</td><td>went</td><td>gone</td><td>走</td></tr><tr><td>take</td><td>took</td><td>taken</td><td>拿</td></tr></tbody></table><h2 id="四、ABB型"><a href="#四、ABB型" class="headerlink" title="四、ABB型"></a>四、ABB型</h2><h3 id="1-原形→ought-→ought"><a href="#1-原形→ought-→ought" class="headerlink" title="1. 原形→ought →ought"></a>1. 原形→ought →ought</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>bring</td><td>brought</td><td>brought</td><td>带来</td></tr><tr><td>buy</td><td>bought</td><td>bought</td><td>买</td></tr><tr><td>fight</td><td>fought</td><td>fought</td><td>打架</td></tr><tr><td>think</td><td>thought</td><td>thought</td><td>思考</td></tr><tr><td>seek</td><td>sought</td><td>sought</td><td>寻求</td></tr></tbody></table><h3 id="2-原形→aught-→aught"><a href="#2-原形→aught-→aught" class="headerlink" title="2. 原形→aught →aught"></a>2. 原形→aught →aught</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>catch</td><td>caught</td><td>caught</td><td>捉,抓</td></tr><tr><td>teach</td><td>taught</td><td>taught</td><td>教</td></tr></tbody></table><h3 id="3-变其中一个元音字母"><a href="#3-变其中一个元音字母" class="headerlink" title="3.变其中一个元音字母"></a>3.变其中一个元音字母</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>feed</td><td>fed</td><td>fed</td><td>喂</td></tr><tr><td>meet</td><td>met</td><td>met</td><td>遇见</td></tr><tr><td>get</td><td>got</td><td>got</td><td>得到</td></tr><tr><td>hold</td><td>held</td><td>held</td><td>拥有</td></tr><tr><td>babysit</td><td>babysat</td><td>babysat</td><td>临时照看</td></tr><tr><td>sit</td><td>sat</td><td>sat</td><td>坐</td></tr><tr><td>win</td><td>won</td><td>won</td><td>赢</td></tr><tr><td>find</td><td>found</td><td>found</td><td>发现</td></tr><tr><td>bend</td><td>bent</td><td>bent</td><td>使弯曲</td></tr><tr><td>dig</td><td>dug</td><td>dug</td><td>挖</td></tr><tr><td>lead</td><td>led</td><td>led</td><td>引导</td></tr><tr><td>sell</td><td>sold</td><td>sold</td><td>卖</td></tr><tr><td>retell</td><td>retold</td><td>retold</td><td>复述</td></tr></tbody></table><h3 id="4-原形→□t→□t"><a href="#4-原形→□t→□t" class="headerlink" title="4. 原形→□t→□t"></a>4. 原形→□t→□t</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>feel</td><td>felt</td><td>felt</td><td>感到</td></tr><tr><td>keep</td><td>kept</td><td>kept</td><td>保持</td></tr><tr><td>leave</td><td>left</td><td>left</td><td>离开</td></tr><tr><td>sleep</td><td>slept</td><td>slept</td><td>睡</td></tr><tr><td>sweep</td><td>swept</td><td>swept</td><td>扫</td></tr><tr><td>smell</td><td>smelt</td><td>smelt</td><td>闻；发出气味</td></tr></tbody></table><h3 id="5-变其中一个辅音字母"><a href="#5-变其中一个辅音字母" class="headerlink" title="5.变其中一个辅音字母"></a>5.变其中一个辅音字母</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>build</td><td>built</td><td>built</td><td>建造</td></tr><tr><td>hear</td><td>heard</td><td>heard</td><td>听见</td></tr><tr><td>make</td><td>made</td><td>made</td><td>制造</td></tr><tr><td>mean</td><td>meant</td><td>meant</td><td>意思</td></tr><tr><td>send</td><td>sent</td><td>sent</td><td>送,寄</td></tr><tr><td>spend</td><td>spent</td><td>spent</td><td>花费</td></tr><tr><td>deal</td><td>dealt</td><td>dealt</td><td>处理</td></tr><tr><td>rebuild</td><td>rebuilt</td><td>rebuilt</td><td>重建</td></tr><tr><td>lend</td><td>lent</td><td>lent</td><td>借贷</td></tr></tbody></table><h3 id="6-辅音字母和元音字母都变"><a href="#6-辅音字母和元音字母都变" class="headerlink" title="6.辅音字母和元音字母都变"></a>6.辅音字母和元音字母都变</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>have</td><td>had</td><td>had</td><td>有,吃</td></tr><tr><td>lay</td><td>lain</td><td>lain</td><td>放</td></tr><tr><td>lose</td><td>lost</td><td>lost</td><td>丢失</td></tr><tr><td>pay</td><td>paid</td><td>paid</td><td>付钱</td></tr><tr><td>say</td><td>said</td><td>said</td><td>说</td></tr><tr><td>sell</td><td>sold</td><td>sold</td><td>卖</td></tr><tr><td>tell</td><td>told</td><td>told</td><td>告诉</td></tr><tr><td>stand</td><td>stood</td><td>stood</td><td>站</td></tr><tr><td>misunderstand</td><td>misunderstood</td><td>misunderstood</td><td>误解</td></tr><tr><td>shoot</td><td>shot</td><td>shot</td><td>放炮；开枪</td></tr><tr><td>understand</td><td>understood</td><td>understood</td><td>理解</td></tr></tbody></table><h2 id="五、AAB型"><a href="#五、AAB型" class="headerlink" title="五、AAB型"></a>五、AAB型</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th align="center">汉语意思</th></tr></thead><tbody><tr><td>beat</td><td>beat</td><td>beaten</td><td align="center">打败</td></tr></tbody></table><h2 id="六、有两种形式"><a href="#六、有两种形式" class="headerlink" title="六、有两种形式"></a>六、有两种形式</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>bear</td><td>bore</td><td>born</td><td>生</td></tr><tr><td>bore</td><td>borne</td><td></td><td></td></tr><tr><td>hang</td><td>hanged</td><td>hanged</td><td>吊死</td></tr><tr><td>hung</td><td>hung</td><td>挂</td><td></td></tr><tr><td>learn</td><td>learned</td><td>learned</td><td>学</td></tr><tr><td>learnt</td><td>learnt</td><td></td><td></td></tr><tr><td>lie</td><td>lied</td><td>lied</td><td>说谎</td></tr><tr><td>lay</td><td>lain</td><td>躺</td><td></td></tr><tr><td>show</td><td>showed</td><td>showed</td><td>给……看</td></tr><tr><td>showed</td><td>shown</td><td></td><td></td></tr><tr><td>spell</td><td>spelled</td><td>spelled</td><td>拼写</td></tr><tr><td>spelt</td><td>spelt</td><td></td><td></td></tr><tr><td>burn</td><td>burned</td><td>burned</td><td>烧</td></tr><tr><td>burnt</td><td>burnt</td><td></td><td></td></tr><tr><td>smell</td><td>smelled</td><td>smelled</td><td>闻</td></tr><tr><td>smelt</td><td>smelt</td><td></td><td></td></tr><tr><td>shine</td><td>shined</td><td>shined</td><td>照耀</td></tr><tr><td>shone</td><td>shone</td><td></td><td></td></tr><tr><td>dream</td><td>dreamed</td><td>dreamed</td><td>做梦</td></tr><tr><td>dreamt</td><td>dreamt</td><td></td><td></td></tr><tr><td>wake</td><td>waked</td><td>waked</td><td>醒</td></tr><tr><td>woke</td><td>woken</td><td></td><td></td></tr><tr><td>hide</td><td>hid</td><td>hid</td><td>躲藏</td></tr><tr><td>hid</td><td>hidden</td><td></td><td></td></tr><tr><td>bite</td><td>bit</td><td>bit</td><td>咬</td></tr><tr><td>bit</td><td>bitten</td><td></td><td></td></tr><tr><td>light</td><td>lighted</td><td>iighted</td><td>点着</td></tr><tr><td>lit</td><td>lit</td><td></td><td></td></tr><tr><td>prove</td><td>proved</td><td>proved</td><td>证明</td></tr><tr><td>proved</td><td>proven</td><td></td><td></td></tr><tr><td>quit</td><td>quit</td><td>quit</td><td>放弃</td></tr><tr><td>quited</td><td>quited</td><td></td><td></td></tr><tr><td>rid</td><td>rid</td><td>rid</td><td>免除；去掉</td></tr><tr><td>ridded</td><td>ridded</td><td></td><td></td></tr><tr><td>saw</td><td>sawed</td><td>sawed</td><td>锯</td></tr><tr><td>sawed</td><td>sawn</td><td></td><td></td></tr><tr><td>sew</td><td>sewed</td><td>sewed</td><td>缝纫</td></tr><tr><td>sewed</td><td>sown</td><td></td><td></td></tr><tr><td>shine</td><td>shone</td><td>shone</td><td>发光；闪亮</td></tr><tr><td>shined</td><td>shined</td><td></td><td></td></tr><tr><td>sink</td><td>sank</td><td>sunk</td><td>下沉</td></tr><tr><td>sank</td><td>sunken</td><td></td><td></td></tr><tr><td>sow</td><td>sowed</td><td>sowed</td><td>种植</td></tr><tr><td>sowed</td><td>sown</td><td></td><td></td></tr><tr><td>spit</td><td>spat</td><td>spat</td><td>吐</td></tr><tr><td>spit</td><td>spit</td><td></td><td></td></tr><tr><td>spring</td><td>sprang</td><td>sprung</td><td>跳跃</td></tr><tr><td>sprung</td><td>sprung</td><td></td><td></td></tr><tr><td>wet</td><td>wet</td><td>wet</td><td>浸湿；弄湿</td></tr><tr><td>wetted</td><td>wetted</td><td></td><td></td></tr></tbody></table><h2 id="七、情态动词"><a href="#七、情态动词" class="headerlink" title="七、情态动词"></a>七、情态动词</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>can</td><td>could</td><td>∕</td><td>能</td></tr><tr><td>may</td><td>might</td><td>∕</td><td>也许</td></tr><tr><td>must</td><td>∕</td><td>∕</td><td>必须</td></tr><tr><td>shall</td><td>should</td><td>∕</td><td>将要</td></tr><tr><td>will</td><td>would</td><td>∕</td><td>会</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>不规则动词总结表</tag>
      </tags>
  </entry>
  <entry>
    <title>高数公式</title>
    <url>/archives/29c7973.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h1 id="高数数学所有公式总结"><a href="#高数数学所有公式总结" class="headerlink" title="高数数学所有公式总结"></a>高数数学所有公式总结</h1><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_1.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_2.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_3.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_4.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_5.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_6.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_7.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_8.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_9.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_10.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_11.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_12.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_13.png" alt></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>高数公式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中$event的用法——如何获取当前兄弟元素，子元素，父元素</title>
    <url>/archives/378703a1.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tempalte&gt;</span><br><span class="line"></span><br><span class="line">   &lt;button @click = “getEvent($event)”&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">      methods:&#123;</span><br><span class="line"></span><br><span class="line">         getEvent(e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// e.target 是你当前点击的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// e.currentTarget 是你绑定事件的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           #获得点击元素的前一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.innerHTML</span><br><span class="line"></span><br><span class="line">           #获得点击元素的第一个子元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.firstElementChild</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的下一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.nextElementSibling</span><br><span class="line"></span><br><span class="line">           # 获得点击元素中id为string的元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getElementById(<span class="string">"string"</span>)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的string属性</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getAttributeNode(<span class="string">'string'</span>)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的父级元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.parentElement</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的前一个元素的第一个子元素的HTML值</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.firstElementChild.innerHTML</span><br><span class="line"></span><br><span class="line">         &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Jsp中的session</title>
    <url>/archives/fdcf16bb.html</url>
    <content><![CDATA[<!-- build time:Mon Nov 29 2021 21:45:52 GMT+0800 (中国标准时间) --><p>Jsp中的session</p><p>1.什么是session:<br>当用户打开浏览器，访问某个网站的时候，服务器就会在服务器的内存为该浏览器分配一个内存空间，该空间被这个浏览器独占，这个空间就是session空间。<br>该空间中的数据默认存在时间为30min,可以修改(session.setMaxInactiveInterval(int seconds))</p><p>2.session可以用来做什么？<br>（1）可以用作网上商城的购物车<br>（2）保存登录用户的信息<br>（3）将某些数据放在session中，供同一用户的各个页面使用（共享数据）<br>（4）防止用户非法登录到某个页面</p><p>3.session的使用：<br>（1）得到session<br>servlet中：HttpSession hs = request.getSession(true);<br>jsp中:session是一个内置对象，可以直接使用<br>(2)向session添加属性：<br>servlet中：hs.setAttribute(String name,Object value)<br>jsp中：session.setAttribute(String name,Object value)<br>(3)从session得到某个属性：<br>servlet中：hs.getAttribute(String name)<br>jsp中：session.getAttribute(String name)<br>(4)从session中删除某个属性：<br>servlet中:hs.removeAttribute(String name)<br>jsp中:hs.removeAttribute(String name)</p><p>4.session注意事项：<br>（1）session默认存在时间是30分钟，在tomcat的web.xml中的<session-out>可以修改<br>（2）上述默认时间指的是“发呆时间”，不是累计时间，就是不访问它的时间超过30分钟就会被回收，期间访问了它的话这个时间就会重新计算<br>（3）当某个浏览器访问服务器时，服务器会给它一个唯一的session id,通过id来区分不痛的浏览器<br>（4）因为session要占用服务器内存，因此在迫不得已的情况下才使用（一般使用：保存用户信息，保存购物车）…</session-out></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>解决eclipse端口被占用</title>
    <url>/archives/969da7de.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h4 id="解决eclipse端口被占用"><a href="#解决eclipse端口被占用" class="headerlink" title="解决eclipse端口被占用"></a>解决eclipse端口被占用</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-801d15d118d7c3e5.png" alt="5640239-801d15d118d7c3e5.png"></p><p>问题如图所示，在eclipse中开启tomcat服务器时报错：端口已被占用。</p><p>这是因为在tomcat开启的状态下，eclipse异常关闭，导致tomcat一直占用端口。<br>解决办法如下：</p><p>1： 输入命令netstat -ano|findstr “8080”，查看8080端口是否被占用，且得到了进程号“13384”；</p><p>2： 再输入命令tasklist|findstr “13384”，得到进程映像名javaw.exe；</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-779a4d67255f5cfb.png" alt="5640239-779a4d67255f5cfb.png"></p><p>3： 启动任务管理器，结束javaw.exe进程；</p><ul><li>用鼠标打开任务管理器，首先鼠标放在电脑最下边靠右边的任务栏上，点击右键</li></ul><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-16874fe86025821b.png" alt="5640239-16874fe86025821b.png"></p><p>选择启动任务管理器，用鼠标左键单击，就打开了任务管理器</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-a6d975126589654c.jpg" alt="5640239-a6d975126589654c.jpg"></p><p>找到13384所对应的程序，结束任务</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-390417a76c06c5c7.png" alt="5640239-390417a76c06c5c7.png"></p><ol start="4"><li>最后再输入命令netstat -ano|findstr “8080”，查看8080端口是否被还占用</li></ol><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-dbccc1732c77b015.png" alt="5640239-dbccc1732c77b015.png"></p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>eclipse端口被占用解决办法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue获取节点总结</title>
    <url>/archives/a8f7bb1e.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="vue获取各个节点的方式"><a href="#vue获取各个节点的方式" class="headerlink" title="vue获取各个节点的方式"></a>vue获取各个节点的方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tempalte&gt;</span><br><span class="line"></span><br><span class="line">   &lt;button @click &#x3D; “getEvent($event)”&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   export default &#123;</span><br><span class="line"></span><br><span class="line">      methods:&#123;</span><br><span class="line"></span><br><span class="line">         getEvent(e) &#123;</span><br><span class="line"></span><br><span class="line">            console.log(e)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; e.target 是你当前点击的元素</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; e.currentTarget 是你绑定事件的元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           #获得点击元素的前一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.innerHTML</span><br><span class="line"></span><br><span class="line">           #获得点击元素的第一个子元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.firstElementChild</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的下一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.nextElementSibling</span><br><span class="line"></span><br><span class="line">           # 获得点击元素中id为string的元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getElementById(&quot;string&quot;)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的string属性</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getAttributeNode(&#39;string&#39;)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的父级元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.parentElement</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的前一个元素的第一个子元素的HTML值</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.firstElementChild.innerHTML</span><br><span class="line"></span><br><span class="line">         &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue获取节点总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库总结</title>
    <url>/archives/3086330.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-如何在命令行配置MYSQL数据库"><a href="#1-如何在命令行配置MYSQL数据库" class="headerlink" title="1.如何在命令行配置MYSQL数据库"></a>1.如何在命令行配置MYSQL数据库</h3><p>1）找到MYSQL安装目录的bin目录</p><p>2）放置到path环境变量中</p><h3 id="2-启动停止MYSQL"><a href="#2-启动停止MYSQL" class="headerlink" title="2.启动停止MYSQL"></a>2.启动停止MYSQL</h3><p>启动： netstarmysqla 停止：mysql net stop mysqla</p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>binary,int,float,double,char,varchar,text,datetime</p><h3 id="4-添加数据库"><a href="#4-添加数据库" class="headerlink" title="4.添加数据库"></a>4.添加数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="5-查看数据库"><a href="#5-查看数据库" class="headerlink" title="5.查看数据库"></a>5.查看数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">show create database;</span><br></pre></td></tr></table></figure><h3 id="6-删除数据"><a href="#6-删除数据" class="headerlink" title="6.删除数据"></a>6.删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="7-使用数据库前需要先打开数据表所在的数据库"><a href="#7-使用数据库前需要先打开数据表所在的数据库" class="headerlink" title="7.使用数据库前需要先打开数据表所在的数据库"></a>7.使用数据库前需要先打开数据表所在的数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><h3 id="8-创建表"><a href="#8-创建表" class="headerlink" title="8.创建表"></a>8.创建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名(字段1 类型（长度）,[约束]，.....);</span><br></pre></td></tr></table></figure><h3 id="9-查询当前数据库下有哪些表"><a href="#9-查询当前数据库下有哪些表" class="headerlink" title="9.查询当前数据库下有哪些表"></a>9.查询当前数据库下有哪些表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables</span><br></pre></td></tr></table></figure><h3 id="10-查询表结构"><a href="#10-查询表结构" class="headerlink" title="10.查询表结构"></a>10.查询表结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sesc student</span><br></pre></td></tr></table></figure><h3 id="11-数据库备份与还原"><a href="#11-数据库备份与还原" class="headerlink" title="11.数据库备份与还原"></a>11.数据库备份与还原</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump-uroot-p first-db&gt;C:123456.sql</span><br></pre></td></tr></table></figure><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>1.数据库没有大小写之分</p><p>2.关键词大写，自定义的小写<br>3.修改表内容的关键词</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 （动作）</span><br><span class="line">改表名 动作 rename 新表名</span><br><span class="line">改字段类型 动作 modify 字段名 新类型</span><br><span class="line">改字段名称 动作 change 旧名称 新名称 新类型</span><br><span class="line">增加字段 动作 add 新增字段名 新增字段类型</span><br><span class="line">删除字段 动作 drop 字段名</span><br><span class="line">删除表 drop table 表名;</span><br><span class="line">删除数据库 drop database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="1、数据完整性"><a href="#1、数据完整性" class="headerlink" title="1、数据完整性"></a>1、数据完整性</h3><p>主键约束 primary key 特点是非空且唯一<br>两种写法，直接写在字段后，或者写在创建语句最后 primary key（字段名）<br>联合主键 写在创建语句最后 primary key(字段 1，字段 2)</p><h3 id="2、设置字段自增长-auto-increment"><a href="#2、设置字段自增长-auto-increment" class="headerlink" title="2、设置字段自增长 auto_increment"></a>2、设置字段自增长 auto_increment</h3><p>数据表只有一个自增长列，为主键列</p><h3 id="3、外键约束-foreign-key"><a href="#3、外键约束-foreign-key" class="headerlink" title="3、外键约束 foreign key"></a>3、外键约束 foreign key</h3><p>写在创建语句最后 foreign key (从表字段名) references 主表名<br>（主表字段名）</p><h3 id="4、非空约束-not-null"><a href="#4、非空约束-not-null" class="headerlink" title="4、非空约束 not null"></a>4、非空约束 not null</h3><h3 id="5、默认约束-default-值，注意字符串，需外加单引号"><a href="#5、默认约束-default-值，注意字符串，需外加单引号" class="headerlink" title="5、默认约束 default 值，注意字符串，需外加单引号"></a>5、默认约束 default 值，注意字符串，需外加单引号</h3><h3 id="6、唯一约束-unique"><a href="#6、唯一约束-unique" class="headerlink" title="6、唯一约束 unique"></a>6、唯一约束 unique</h3><p>主键约束和唯一约束的区别，主键无意义，唯一约束可以为 null<br>设计规范<br>1NF（第一范式）保证数据列的原子性<br>家庭住址 可分为省 市 县 具体地址<br>2NF 保证每列都和主键相关（唯一主键，联合主键不满足）<br>学号 姓名 课程 教材 教材内容<br>1 张三 数据库 mysql XXXXX（1 千字）<br>1 张三 java java<br>2 李四 数据库 mysql XXXXX（1 千字）<br>3 王五 数据库 mysql XXXXX（1 千字）<br>数据冗余 更新异常 插入异常 删除异常</p><p>3NF 保证每列都和主键直接相关<br>学号 姓名 班级 辅导员编号 辅导员姓名 辅导员家庭住址</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="数据库的增删改操作"><a href="#数据库的增删改操作" class="headerlink" title="数据库的增删改操作"></a>数据库的增删改操作</h3><h3 id="1、插入数据"><a href="#1、插入数据" class="headerlink" title="1、插入数据"></a>1、插入数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名（列 1，列 2，。。。） values（值 1，值 2，。。。）；</span><br><span class="line">查询数据</span><br><span class="line">select * from 表名;</span><br></pre></td></tr></table></figure><h3 id="2、into-关键字可以省略"><a href="#2、into-关键字可以省略" class="headerlink" title="2、into 关键字可以省略"></a>2、into 关键字可以省略</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简写形式 insert 表名（列 1，列 2，。。。） values（值 1，值 2，。。。）；</span><br></pre></td></tr></table></figure><h3 id="3、全列插入可省略列明"><a href="#3、全列插入可省略列明" class="headerlink" title="3、全列插入可省略列明"></a>3、全列插入可省略列明</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简写形式 insert 表名 values（值 1，值 2，。。。）；</span><br></pre></td></tr></table></figure><h3 id="4、自增列和默认列可省略"><a href="#4、自增列和默认列可省略" class="headerlink" title="4、自增列和默认列可省略"></a>4、自增列和默认列可省略</h3><p>注意：自增列只增不减<br>除非：alter table 表名 set auto_increment=值;<br>或者 truncate table 表名; 清空表，自增从 1 开始记数</p><h3 id="5、一次插入多行"><a href="#5、一次插入多行" class="headerlink" title="5、一次插入多行"></a>5、一次插入多行</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 表名（列 1，列 2，。。。） values（值 1，值 2，。。。），（值 1，</span><br><span class="line">值 2，。。。），。。。。；</span><br></pre></td></tr></table></figure><h3 id="6、比较运算"><a href="#6、比较运算" class="headerlink" title="6、比较运算"></a>6、比较运算</h3><p>大于&gt;=大于等于&lt;小于&lt;=小于等于 =等于 !=或&lt;&gt;不等于</p><p>is null 为空 is not null 非空 in 在某个范围 not in 不在某个范<br>围 like 模糊查询 between and 在某个范围</p><h3 id="7、逻辑运算"><a href="#7、逻辑运算" class="headerlink" title="7、逻辑运算"></a>7、逻辑运算</h3><p>not 非 and 并且 or 或者</p><h3 id="8、修改数据"><a href="#8、修改数据" class="headerlink" title="8、修改数据"></a>8、修改数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 列名 1&#x3D;值 1，列名 2&#x3D;值 2… where 条件;</span><br></pre></td></tr></table></figure><p>如果没有 where 全更新</p><h3 id="9、删除数据"><a href="#9、删除数据" class="headerlink" title="9、删除数据"></a>9、删除数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 条件;</span><br></pre></td></tr></table></figure><p>注意删除数据不更改自增列的值</p><h3 id="10、清空数据"><a href="#10、清空数据" class="headerlink" title="10、清空数据"></a>10、清空数据</h3><p>truncate table 表名功能同 delete from 表名<br>但是<br>1&gt;Delete 无法修改自增列，truncate 重置自增列<br>2&gt;Delete 可以删除外键约束，truncate 只能清空数据，无法删除外<br>键约束<br>3&gt;Delete 可以通过备份和日子恢复，truncate 无法恢复</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><strong>注意：</strong><br>1、数据库没有双引号，字符一定要用单引号包括<br>2、字段名不用引号，单引号包括的一定是字符<br>``(数字键 1 左边的键)</p><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>select 字段 1、字段 2… from 表名 where 条件 order by 字段 1、<br>字段 2.. limit 数字 1,数字 2;<br>*是通配符，表示所有字段<br>使用 as 为字段重命名</p><h3 id="3、where-查询条件"><a href="#3、where-查询条件" class="headerlink" title="3、where 查询条件"></a>3、where 查询条件</h3><h3 id="4、distinct-查询不重复字段"><a href="#4、distinct-查询不重复字段" class="headerlink" title="4、distinct 查询不重复字段"></a>4、distinct 查询不重复字段</h3><h3 id="5、limit-n-m"><a href="#5、limit-n-m" class="headerlink" title="5、limit n,m"></a>5、limit n,m</h3><p>从 n+1 行开始取，取 m 行，行数从 0 开始<br>limit n,取前 n 行</p><h3 id="6、order-by-字段-1"><a href="#6、order-by-字段-1" class="headerlink" title="6、order by 字段 1"></a>6、order by 字段 1</h3><p>通过字段 1 将表从小到大排列<br>order by 字段 1 desc<br>order by 字段 1,字段 2<br>先按照字段 1 排列，在字段 1 相同的情况下按照字段 2 排列</p><p>成绩表，姓名，成绩<br>查询一下第 3 到 6 的女学生姓名<br>select 姓名 from 成绩表 where 性别=’女’ order by 成绩 desc<br>limit 2,4;<br>MySQL 函数<br>concat(‘今天’,’晴天’) 拼接字符串<br>length(‘hello world’) 计算长度，一个字符，符号，数字占 1 位，<br>一个汉字占 3 位<br>upper(‘abcd’) 转成大写<br>ltrim(‘ abc’) 清除左侧空格<br>rtrim(‘abc ‘) 清除右侧空格<br>trim(‘ abc ‘) 清除两侧空格<br>replace(‘abccd’,’c’,’x’) 将 abccd 中的所有 c 替换成 x<br>strcmp(‘a’,’b’) 比较字符串大小<br>substring(‘abcdefg’,3,3) 取子串，从第 3 个开始取，取 3 个<br>数学函数<br>rand(); 取 0~1 的随机小数，取不到 0 和 1<br>ceil();向上取整<br>floor(); 向下取整</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="模糊查询和分组查询"><a href="#模糊查询和分组查询" class="headerlink" title="模糊查询和分组查询"></a>模糊查询和分组查询</h3><p>模糊查询使用 like 关键字， _代表一个字符 ，%代表任意长度的字<br>符（0 也是任意长度）<br>between and 关键字，表示大于等于第一个数，小于等于第二个数<br>select * from stuinfo where age between 18 and 20;where age &gt;=18 and age&lt;=20;<br>聚合函数<br>求和 sum，平均 avg，最大 max，最小 min，个数 count(<em>)使用聚合函数只有一行结果分组查询group by 写在 where 后面，order by 前面select \</em> from stuinfo group by age;只有聚合函数和被分组的列有意义使用 having 对分组结果进行条件查询，写在 group by 后面P43 count(*)和 count(列名)<br>count(列名)，如果列里面是 null 的，不计入总数</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>数据库有3中连接方式（MySQL有），其他数据库如（Oracle，SQL Server）<br>有 4 中包括全连接</p><h3 id="1、内连接"><a href="#1、内连接" class="headerlink" title="1、内连接"></a>1、内连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1，表 2 WHERE 条件</span><br></pre></td></tr></table></figure><p>另一种写法</p><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 INNER JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="2、左连接"><a href="#2、左连接" class="headerlink" title="2、左连接"></a>2、左连接</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 LEFT JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="3、右连接"><a href="#3、右连接" class="headerlink" title="3、右连接"></a>3、右连接</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 RIGHT JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="4、全连接"><a href="#4、全连接" class="headerlink" title="4、全连接"></a>4、全连接</h3><p>先左连接再右连接</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA面向对象总结</title>
    <url>/archives/4732fab1.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="第二章：类和对象的创建"><a href="#第二章：类和对象的创建" class="headerlink" title="第二章：类和对象的创建"></a>第二章：类和对象的创建</h2><p>概念：面向对象就是把一个项目，一个事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。</p><p>好处：面相对象更接近实物的本质，提高代码的复用更具有扩展性。</p><p>如何使用：通常是创建类的对象再给属性赋值。</p><p>构造方法：构造方法的名称和类名相同，没有返回值类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO g&#x3D;new GO();</span><br></pre></td></tr></table></figure><p>构造方法的重载：方法名相同，参数列表不同，这是构造方法的重载。</p><p>如果一个类中包含了两个或两个以上的方法，他们方法名相同，方法参数个数或者参数类型不同，则称该方法被重载了，这个过程是方法重载。</p><p>Static：可以用来修饰属性，方法和代码块，静态方法中不能使用this和super关键字。</p><h2 id="第三章：封装"><a href="#第三章：封装" class="headerlink" title="第三章：封装"></a>第三章：封装</h2><p>概念：封装指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>好处：提高了安全性 提高了复用性 提高了实现细节</p><p>注意事项：类的属性中均用private来修饰 定义geter和seter方法</p><h2 id="第四章：继承"><a href="#第四章：继承" class="headerlink" title="第四章：继承"></a>第四章：继承</h2><p>概念：比如FeiGe快递系统中有三个实体类Person（人），Courier（快递员）,Customer（客户）类，Courier,Customer都属于（派生类）Person，所以都继承（extends）自Person类。</p><p>好处：提高了代码的重用性 提高了代码的扩展性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：class 类名 extends父接口&#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;属性定义</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;方法定义&#125;</span><br></pre></td></tr></table></figure><p>注意事项：1.子类继承父类所以的属性和方法，只不过只能调用非Private属性和方法2.java中的继承只支持单继承，意思是一个子类只能继承一个父类，但是允许多层继承</p><p>继承中的构造方法：调用父类中的构造方法，</p><p>需用到关键字super super指代父类</p><p>重写的概念：在继承的关系中。子类会自动继承父类中定义的方法，但有时子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：void 方法名（）&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意事项：子类重写父类的方法时，不能使用比父类中被重写的方法更严格的访问权限，重写方法和被重写方法必须具有相同的方法名，相同的参数列表和相同的返回值类型，重写方法的访问修饰符必须大于被重写方法的访问修饰符，否则就不能被称为方法的重写。</p><p>异常的处理：在程序执行代码的时候万一发生了异常，程序会按照预定的处理方法对异常进行处理，异常处理完毕之后，程序继续运行。</p><h3 id="语法：5个关键字-try-catch-finally-throw-throws"><a href="#语法：5个关键字-try-catch-finally-throw-throws" class="headerlink" title="语法：5个关键字 try catch finally throw throws"></a>语法：5个关键字 try catch finally throw throws</h3><p>常见的异常类型</p><p>Exception 异常层次的根类 ArithmeticException 算术错误情形，如以零作除数</p><p>ArrayIndexOutOfBoundsException 数组下标越界</p><p>NullPointerException空指针异常</p><p>ClassNotFoundException不能加载所需的类</p><p>InputMismatchException得到的数据类型与实际输入的类型不匹配</p><p>llegalArgumentException方法接收到非法参数</p><p>ClassCastException对象强制类型转换出错</p><p>NumberFormatException数字格式转换异常，如把“abc”转换成数字</p><h2 id="第五章：多态"><a href="#第五章：多态" class="headerlink" title="第五章：多态"></a>第五章：多态</h2><p>概念：指允许不同类的对象对同一消息做出响应即同同一消息可以根据发送对象的不同而采用多种不同的行为方式。</p><p>好处：可替换性 可扩充性 接口性 灵活性 简化性</p><p>多态的使用：</p><p>子类向父类转换称为向上转型</p><h3 id="向上转型：-lt-父类型-gt-lt-引用变量名-gt-new-lt-子类型-gt-（）；"><a href="#向上转型：-lt-父类型-gt-lt-引用变量名-gt-new-lt-子类型-gt-（）；" class="headerlink" title="向上转型：&lt;父类型&gt;&lt;引用变量名&gt;=new&lt;子类型&gt;（）；"></a>向上转型：&lt;父类型&gt;&lt;引用变量名&gt;=new&lt;子类型&gt;（）；</h3><p>将一个指向子类对象的父类引用赋给一个子类的引用，即将父类类型转换子类类型，称为向下转型，此时必须进行强制类型转换。</p><h3 id="向下转型：-lt-子类型-gt-lt-引用变量名-gt-（-lt-子类型-gt-）-lt-父类型的引用变量-gt-；"><a href="#向下转型：-lt-子类型-gt-lt-引用变量名-gt-（-lt-子类型-gt-）-lt-父类型的引用变量-gt-；" class="headerlink" title="向下转型：&lt;子类型&gt;&lt;引用变量名&gt;=（&lt;子类型&gt;）&lt;父类型的引用变量&gt;；"></a>向下转型：&lt;子类型&gt;&lt;引用变量名&gt;=（&lt;子类型&gt;）&lt;父类型的引用变量&gt;；</h3><p>运算符：instanceof 进行类型的判断</p><p>Try-catch-finally 如果try中的所有语句正常执行完毕那么finally块就会被执行</p><p>多重catch 一段代码会出现多种异常这时可以在try语句后写多个catch语句块</p><h2 id="第六章：抽象"><a href="#第六章：抽象" class="headerlink" title="第六章：抽象"></a>第六章：抽象</h2><p>概念：如果一个类没有足够的信息去描述一个具体的对象那我们就称之为抽象类</p><p>语法：public abstract class类名{}</p><p>作用：抽象类是用来继承的比普通类更通用</p><p>抽象方法：abstract修饰没有方法体之声明返回的数据类型 方法名称和所需要的参数</p><p>语法 ：public abstract 返回值类型 方法名（参数列表）；</p><p>注意事项：包含抽象方法的类一定是抽象类 抽象类中不一定都是抽象方法 构造方法不能生命为抽象方法 abstract不能与private static final native 并列修饰同一个方法</p><p>Final 修饰类 被final修饰过的类不能被继承 因为不能被继承所以此类中所有方法都是final修饰 该类如果不需要有子类不需要被扩展类的方法不允许被重写就用final修饰该类</p><p>Throws通过try-catch捕获处理异常</p><h2 id="第七章：接口"><a href="#第七章：接口" class="headerlink" title="第七章：接口"></a>第七章：接口</h2><p>概述：在软件中接口是一种规范和标准他们可以约束类的行为是一些方法特征的集合但是没有方法的实现</p><p>语法：</p><p>【修饰符】interface接口名extends父接口1，父接口2……{//常量定义//方法定义}</p><p>Class类名extends父类名implements接口1，接口2….{//类成员}</p><p>Run（）；方法提供服务</p><p>接口是一种能力接口是一种约定</p><p>抛出异常：throw 除系统自动抛出异常可以用throw自动抛出异常</p><p>Throw在程序中抛出异常throws在方法内抛出异常</p><p>第八章：集合框架</p><p>集合框架使用方便的接口和类都在java.util包中</p><p>集合框架的特点：</p><p>长度 数组长度是固定的集合长度是可变的</p><p>存储对象 数组可以存储基本的数据类型，也可以存储对象的引用 集合只能用于存储对象的引用</p><p>对象类型 数组必须是相同类型的数据 对象可以是不同类型</p><p>接口区别：</p><p>Collection接口存储组 不唯一(允许重复)、 无序的对象。<br>Set接口继承Collection接口，存储-组唯一(不允许重复)、 无序的对象。<br>List接口继承Collection接口，存储组不唯-(允许重复)、 有序(以元素插入的次序来放置无素，不会重新排列)的对象<br>Map接口存储组成对的键 值对象，提供key(键)到value(值)的映射。Map中的key不要求有序，不允许重复。value 同样不要求有序，但允许重复。</p><p>List接口：</p><p>实现List接口的常用类有ArayList和Lnkedist.它们都可以容纳所有类型的对象，包括nll允许重复，并且都保证元素的存储顺序。<br>ArrayList和LinkedList的大致区别:<br>arraylist是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构对于随机访问get和set, ArrayList 优于LinkedList, 因为LinkedList要移动指针。<br>对于新增和删除操作add和remove, LinkedList 比较占优势，因为ArrayList要移动数据。</p><p>list接口定义中的格各种常用方法</p><p>boolean add(Object o)在列表末尾顺序添加元素，起始索引位置从0开始<br>int size()返回列表中的元素个数<br>void add(int index,Objecto)在指定的索 引位置添加元素，原索引位置及其后面的元素依次后移<br>注意:新添加元素的索引位置必须介于0和列表中元素个数之间</p><p>0bject get(int index)返回指定索引位置处的元素<br>注意:取出的元素是Object类型，使用前需要进行强制类型转换<br>boolean contains(Object o)判断列表中是否存在指定元素<br>boolean remove(Object o)从列表中删除元素<br>Object remove(int index)从列表中删除指定位置元素，起始索引位置从0开始</p><p>Linkedlist的一些特殊用法<br>void addFirst(Object o)在列表的首部添加元素<br>void addLast(Object o)在列表的末尾添加元素<br>Object getFirst( )返回列表中的第一” 个元素<br>Object getLast( )返回列表中的最后一个元素<br>Object removeFirst( )删除并返回列表中的第一个元素</p><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Hashset的优点就是各方面都很快但数据是无序的</p><p>Threeset优点是有序而且可以按照升序方式进行排序，但是其他各方面不突出</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Object put （object key，object value）以“键一值对”的方式进行存储<br>如果武图添加重复的<br>键，那么最后加入的“键-值对”将替换掉原先的“键一道<br>对”<br>Object get (Object key)根据键返回相关联的值，若不存在指定的键，则返回null</p><p>Object remove (Object key)删除指定的键映射的“键一值对”<br>int size()返回元素个数<br>Set keySet()返回键的集合<br>Collection values( )返回值的集合<br>boolean containsKey (Object key)若存在指定的键映射的“键值对”，则返回true<br>boolean isEmpty( )若不存在键一值映射关系，则返回true<br>void clear()从此映射中移除所有映射关系<br>泛型集合：list ArrayList</p><p>ArrayL ist&lt;0bject&gt; list=new ArrayL ist&lt;0bject&gt;() ;</p><p>list. add (0);</p><p>list. add(99.9);</p><p>list. add(false);</p><p>使用泛型集合在创建集合对象时指定集合中元素的类型，从集合中取出元素时无须进行类型强制转换，并且如果把非指定类型对象放入集合，会出现编译错误。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>中国近代史复习</title>
    <url>/archives/49b0d68c.html</url>
    <content><![CDATA[<!-- build time:Fri Dec 24 2021 14:22:59 GMT+0800 (中国标准时间) --><p><strong>《中国近代史纲要》考试要点资料整理</strong></p><p><strong>第一章 反对外国侵略的斗争</strong></p><p><strong>选择题</strong>：</p><p>1、清朝唯一盛世时期是康乾盛世。</p><p>2、1640年英国资产阶级革命爆发，资本主义的发展突出表现在工业革命的爆发上。</p><p>3、所谓的殖民地是指商品倾销市场、廉价劳动力、廉价原料的供应地和自由投资市场。</p><p>4、列强对中国的侵略主要有军事侵略、政治控制、经济掠夺、文化渗透。</p><p>5、1840年，英国发动第一次鸦片战争，中国战败。1856年，英法国发动第二次鸦片战争，发动了著名的“火烧圆明园”；1900年，八国联军发动侵华战争并签订《辛丑条约》</p><p>6、中国割让香港岛给英国是在中英《南京条约》中规定的。</p><p>7、割占中国最多的帝国是俄国，赔款最多的是《辛丑条约》。</p><p>8、1894年日本发动甲午战争后签订的《马关条约》允许日本在中国设厂，各国开始大规模的对华进行资本输出。</p><p>9、中国革命的主力军是农民阶级。中国民族资产的特性是革命性、软弱性或妥协性。</p><p>10、中国第一次大规模的反侵略武装斗争是广州三元里人民斗争。</p><p>11、鸦片战争战死虎门的将领是关天培，镇南关大捷的指挥大将是冯子材，甲午中日战争中战死的爱国将领有邓世昌、林永升、丁汝昌、刘步蟾。</p><p>12、要求中国实行门户开放政策的是美国，列强不能灭亡和瓜分中国的根本原因是中国人民进行了不屈的反侵略斗争。</p><p>13、近代中国睁眼看世界的第一人是林则徐，他编写了《四洲志》，魏源的《海国图志》是在综合了世界各国历史，地理及对外政策后提出了“师夷长技以制夷”的思想，严复翻译了《天演论》。</p><p><strong>简述题：</strong></p><p>1、简述中国封建社会的基本特点？</p><p>在经济上，封建土地所有制占主导地位；在政治上，实行高度中央集权的封建君主专制制度；在文化上，以儒家思想为核心；在社会结构上，是族权和政权相结合的封建宗法等级制度；中国封建社会的主要矛盾是地主阶级和农民阶级的矛盾。</p><p>2、为什么说1840年第一次鸦片战争是中国近代史的开端？</p><p>第一次鸦片战争以中国失败而告终，主权独立受到侵犯，领土完整遭到破坏，中国逐渐沦入国家主权受制于外国列强的半殖民地社会；鸦片战争后，随着五口通商和西方商品在中国的倾销，促使中国传统的封建的自给自足的自然经济开始解体。</p><p>3、简述近代中国半殖民地半封建社会的特点是什么？</p><p>资本帝国主义成为支配中国的决定性力量；中国封建势力成为外国列强压迫、奴役中国人民的社会基础和统治支柱；封建剥削制度封建地主的徒弟所有制在广大地区保持着；中国资本主义没有成为中国社会经济的主体；近代中国各地区经济、政治和文化和发展是及不平衡的；人民毫无政治权利和生活的极端贫困化。</p><p>4、简述社会阶级关系的变动？</p><p>旧的封建统治阶级——地主阶级继续拥有大量的土地；旧的被统治阶级——农民阶级仍是近代中国社会人数最多的被剥削阶级；中国资产阶级分为官僚买办资产阶级和民族资产阶级两部分。</p><p>5、简述中国工人阶级为何具有无产阶级的特点?</p><p>深受帝国主义，封建势力和资产阶级三重压迫和剥削，革命性最强；人数虽少，但相对集中，便于</p><p>形成革命的力量和传播先进的思想；同农民天然的联系，便于结成工农联盟；因此中国工人阶级是近代中国社会中最先进、最革命、最有力量的阶级。</p><p>6、简述近代中国的两对主要矛盾及其关系？</p><p>①在半殖民地半封建的中国，帝国主义与中华民族的矛盾、封建主义与人民大众的矛盾是两对主要矛盾，而帝国主义与中华民族的矛盾是各种矛盾中最主要的矛盾；②两对主要矛盾之间的关系，一是当外国列强向中国发动侵略战争时，民族矛盾上升到主要地位；二是当外国侵略者同中国封建政权相勾结共同镇压中国革命时，阶级矛盾就上升为主要矛盾；三是国内战争发展到直接威胁帝国主义在华利益及中国封建地主阶级统治时，帝国主义和国内封建主义完全公开站在一条线上。</p><p>7、简述中国两大历史任务及其关系？</p><p>①近代中国社会的性质和主要矛盾决定了近代以来中华名族始终面临两大历史任务：一是球的民族独立和人民解放；二是实现国家繁荣富强和人民共同富裕。②两大历史任务既相互区别，又相互联系。其区别在于，前者要改变民族遭压迫、人民受剥削的地位和状况，是要从根本上解决生产关系问题；后者是要改变近代中国经济、文化和社会落后的地位和状况，解决生产力问题。其联系在于，只有完成第一大任务，才能为第二大任务的完成创造条件。</p><p>8、简述反侵略斗争失败及其原因？</p><p>一是社会制度的腐败；二是经济技术的落后，前者是根本原因。</p><p><strong>第二章 对国家出路的早期探索</strong></p><p><strong>选择题：</strong></p><p>1、1851年的金田起义是太平运动的起点；太平天国由胜转衰的转折点是天京事变；1864年7月天京被攻破，太平天国农民战争失败。</p><p>2、《天朝田亩制度》所建立的理想社会是“有田同耕、有饭同食、有衣同穿、有钱同使、无处不均匀、无处不饱暖”。</p><p>3、对洋务事业的指导思想最先做出比较完整表述的是冯桂芬，洋务运动的性质是“自救”活动，其指导思想是“中学为体，西学为用”；北洋海军全军覆没，标志着洋务运动的失败。</p><p>4、维新变法最早开始于1895年的“公车上书”；其后康有为撰写了《新学伪经考》、《孔子改制考》、《人类公理》等著作；当时影响最大的学会是强学会、南学会和保国会等；影响较大的报纸有上海《时务报》、天津《国闻报》、湖南《湘报》等。</p><p>5、对抗维新变法的代表作是湖广总督张之洞写的《劝学篇》。</p><p><strong>简述题：</strong></p><p>1、简述太平天国农民战争爆发的根本原因？</p><p>一是封建专制政权和地主阶级对农民的政治压迫和经济剥削；二是鸦片战争带来的恶果，使得中国社会的阶级矛盾普遍激化了；前者是战争爆发的根本原因。</p><p>2、简述太平天国的纲领文件。</p><p>太平天国前期的《天朝田亩制度》是一个以解决土地问题为中心的比较完整的社会改革方案，但此纲领并没有超出农民小生产者的狭隘眼界，它所追求的理想天国是一种绝对平均的理想社会，是不切实际的空想；太平天国后期洪仁玕提出的《资政新篇》是一个带有鲜明的资本主义色彩的改革与建设方案，但通篇为涉及农民问题与土地问题。这一致命的弱点，决定了这个方案从一开始就缺乏实施的阶级基础和社会条件。</p><p>3、简述太平天国运动的历史意义？</p><p>一是它沉重的打击了封建统治阶级，强烈撼动了清政府的统治根基；二它是中国旧式农民战争的最高峰；三是太平天国对孔子及儒家经典予以严厉批评，削弱了封建统治的精神支柱；四是太平天国农民战争有力地打击了外国侵略势力；五是它冲击了西方殖民主义在亚洲的统治。</p><p>4、简述太平天国失败的原因和教训？</p><p>太平天国失败的根本原因是缺乏先进阶级的领导，你哦年国民阶级不是新的生产力和生产关系的代表，带有阶级局限性；太平天国的失败还在于没有科学理论的指导；太平天国起义的失败表明，在半殖民地半封建社会，农民不能担负起领导反帝反封建斗争。</p><p>5、简述洋务运动的内容？</p><p>洋务运动持续时间为30年，其内容主要有兴办近代企业，建立新式海路军，创办新式学堂，派遣留学生。</p><p>6、简述洋务运动的历史意义？</p><p>在客观上促进了中国早期工业和民族资本主义的发展；成为中国近代教育的开端；传播了新知识，打开了人们的眼界；引起了社会风气和价值观念的变化。</p><p>7、简述洋务运动失败的原因？</p><p>洋务运动具有封建性；洋务运动对西方列强具有依赖性；洋务企业的管理具有腐朽性。</p><p>8、简述维新派和守旧派的论战？</p><p>两派之间的论战主要围绕三个问题展开：一是要不要变法；</p><p>二是要不要兴民权、设议院，实行君主立宪；三是要不要废八股、改科举和兴学堂。论战的意义是资产阶级思想与封建主义思想在中国的第一次正面交锋，为维新变法运动作了思想舆论的准备。</p><p>9、简述“百日维新”的主要内容？</p><p>在政治上，改革行政制度；在经济上，保护、奖励农工商业；在军事上，裁撤绿营，改练新式陆军；在文教方面上，改革科举制度，废八股，提倡西学。这些新政的内容，对中国民族资本主义的发展和资产阶级先进文化科学的传播都是十分有利的。</p><p>10、简述戊戌维新运动的意义？</p><p>戊戌维新运动是一次爱国救亡运动；是一场资产性质的政治改革运动；是一场思想启蒙运动；在改良社会风气方面也有不可低估的意义。</p><p>11、简述戊戌维新运动失败的原因和教训？</p><p>戊戌维新运动失败的主要原因在于维新派自身的局限和以慈禧太后为首的强大的守旧势力的反对。维新派自身有三方面的弱点和局限：一是不敢否认封建主义；二是对帝国主义抱有幻想；三是脱离人民群众。戊戌维新以悲剧性的失败而告终，不仅暴露出资产阶级的软弱性，同时也说明在半殖民半封建的中国，企图通过统治者进行自上而下的改良的道路，是行不通的要想实现国家的独立、民主、富强，必须采用革命的手段。</p><p><strong>第三章 辛亥革命</strong></p><p><strong>选择题：</strong></p><p>1、1906年清末新政开始废除科举考试。</p><p>2、中国第一个资产阶级革命组织是孙中山组织的兴中会；其他资产阶级革命团体有黄兴的华兴会，蔡元培的光复会；近代中国第一个全国性的资产阶级性质的政党是中国同盟会，其纲领是“驱除鞑虏，恢复中华，创立民国，平均地权”；同盟会的机关报是《民报》； 三民主义是民族、民权、民生。</p><p>3、20世纪初，资产阶级革命派宣传民主革命思想的代表作有章炳麟的《驳康有为轮革命书》、邹容的《革命军》、陈天华的《警世钟》和《猛回头》。</p><p>4、民生主义的基本方案是核定低价；按价征税，涨价归公，按价收买。</p><p>5、资产阶级组织的武装起义中影响做大的是1911年的广州起义，又称黄花岗起义。人民武装起义尤为强烈的属四川省的保路运动。</p><p>6、辛亥革命的高潮出现在1911年10月10号的武昌起义。1912年中华民国临时政府宣告成立，国号为“中华民国”，1912年为中华民国元年。</p><p>7、中国第一部具有资产阶级共和国宪法性质的法典是《中华民国临时约法》。</p><p>8、北洋军阀统治了中国16年；1915年袁世凯接收了日本提出的“二十一条”。以孙中山为首的革命派与北洋军阀进行的斗争有1913年“二次革命”，1915年蔡锷的护国运动，1917年孙中山率领的第一次护法运动，1919年的第二次护法运动。</p><p>9、1914年孙中山成立的中华革命党，第二次护法战争的失败标志着中国旧民主主义革命的终结。</p><p><strong>简述题：</strong></p><p>1、简述清末新政的内容？</p><p>一是改革管制，整顿吏治；二是改革兵制，训练新军；三是改革学制，提倡新学；四是奖励工商，兴办实业。</p><p>2、试述“三民主义”的内容？</p><p>民族主义包括“驱除鞑虏，恢复中华”两性内容：一是以革命手段推翻清王朝，改变它一贯推行的民族歧视和压迫政策；二是变“次殖民地”的中国为独立的中国，但其没有明确的反帝主张；民权主义内容是“创立民国”，即推翻封建君主主义专制制度，建立资产阶级的民主共和国，但其没有明确劳动人民在国家中的地位；民生主义的内容是“平均主义”，但其没有正面触及封建土地所有制，不能满足农民的土地要求；孙中山的三民主义学说，提出了一套中国历史上不曾有过的资产阶级共和国的建国方案，是一个比较完备的民主主义的革命纲领。</p><p>3、革命派与改良派的辩驳内容与意义？</p><p>内容：一是要不要以革命手段推翻清政府；二是要不要推翻帝制，实行共和；三是要不要社会革命。意义：论战划清了革命与改良的界限，论战使资产阶级民主和三民主义思想得到了更加广泛的份额传播，为推翻清朝统治的革命斗争奠定了思想基础。</p><p>4、为什么说南京临时政府是资产阶级共和国性质的革命政权？</p><p>一是人员构成上，资产阶级革命派控制着这个政权；二是在实行的各项政策措施上，集中体现了中国民族资产阶级的愿望和利益，一定程度上符合广大中国人民的利益。</p><p>5、简述南京临时政府的局限性？</p><p>一是企图用承认清政府与列强所定的的一切不平等条约和所欠的一切外债，来换取列强承认中华民国；二是没有提出可以满足农民土地要求的政策与措施。</p><p>6、简述辛亥革命胜利的历史意义？（为什么说辛亥革命是一次比较完全意义上的资产阶级民主革命？）</p><p>一是推翻了清王朝在中国的统治；二是结束了统治中国两千多年的封建君主专制制度，建立了中国历史上第一个资产阶级共和政府；三是一场思想解放运动；四是推翻了民族资本主义经济的发展；五是打击了帝国主义在华势力。</p><p>7、简述辛亥革命的局限性？（辛亥革命为什么会失败？）</p><p>没有提出彻底的反对帝国主义和反对封建主义的革命纲领；没有充分发动和依靠群众；没有建立坚强的革命政党；资产阶级革命派的软弱性以及由此而来的辛亥革命的局限性，使辛亥革命难以摆脱失败的命运；辛亥革命的失败表明：资产阶级共和国的方案不能救中国。</p><p><strong>第四章 开天辟地的大事件</strong></p><p><strong>选择题：</strong></p><p>1、1915年陈独秀在上海创办的《新青年》，成为新文化运动兴起的标志。</p><p>2、新文化运动的主要内容是提倡民主与科学，还提倡白话文、新文学，反对文言文，主张文学革命。新文化运动的第一篇白话文小说是鲁迅发表的《狂人日记》。</p><p>3、在中国大地率先举起马克思主义旗帜的是李大钊。五四运动斗争目标是“外争国权，内除国贼”。</p><p>4、《共产党宣言》第一个中文全译本是陈望道翻译的。中国第一个地方共产党组织是上海共产主义小组。中国共产党第一、二次全国代表大会都是在上海举行。</p><p>5、第一个产业工会是上海机器工会。第一个农民协会成立在浙江省萧山县衙前村。</p><p>6、中国工人运动掀起高潮的起点是1922年香港海员罢工，终点是1923年京汉铁路工人罢工。中国工人运动史上最长的一次罢工是省港大罢工。</p><p>7、建立革命统一战线的问题是在中共第三次全国代表大会上。国共合作的政治基础和革命统一战线的共同纲领是新三民主主义 。第一次国共合作的政治基础是联俄、联共、扶助农工三大政策。1924年国民党“一大”的召开，标志着以第一次国共合作为基础的革命统一战线正式形成，改组后的国民党改为工人阶级、农民阶级、小资产阶级和民族资产阶级的革命联盟。</p><p>8、1924年成立的黄埔军校把政治教育提到和军事训练同等重要的地位，注重培养学生的爱国思想和革命精神，这是同一切旧式军校的根本区别。</p><p>9、北伐战争的直接目标是打到帝国主义支持北洋军阀。</p><p>10、国民党右派为了打击共产党员和工农革命力量，以蒋介石为首后制造了中山舰事件、整理党务案事件。</p><p><strong>简述题：</strong></p><p>1、简述五四前夕的新文化运动的历史意义？</p><p>一它是资产阶级民主主义的新文化同封建主义旧文化的斗争；二是它大力宣传了民主与科学，启发了人们的理智与民主主义觉悟，开启了思想解放的潮流；三是它为五四运动创造了思想文化上的条件。</p><p>2、简述五四前夕的新文化运动的局限？</p><p>新闻欢运动提倡的资产阶级民主主义，并不能为人们提供一种思想武器去认识中国；他们没有把运动普及到工农群众中去；他们中的不少人在思想方法上存在绝对肯定或绝对否定的形式主义偏向。</p><p>3、简述五四运动的历史特点及意义？</p><p>五四运动是一次彻底的反帝反封建的革命运动；它是一场真正的群众性的革命运动；它促进了马克思主义在中国的广泛的传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立作了思想和干部上的准备；它是中国新民主主义革命的伟大开端。</p><p>4、为什么说五四运动是中国新民主主义革命的伟大开端？</p><p>五四运动发生在俄国十月革命之后，中国革命逐渐成为世界无产阶级社会主义革命的一部分；五四运动以后，无产阶级逐渐代替资产阶级成为近代中国民族民主革命的领导者。</p><p>5、为什么说中国共产党的诞生是马克思主义同中国工人运动相结合的产物？</p><p>五四以后，随着工人运动的发展，工人阶级急切需要找到实现本阶级意志的精神武器；马克思主义的广泛传播，也迫切需要从工人阶级中找到物质力量。</p><p>6、早期共产党组织的成员同反马克思主义的思潮进行了那三次论战？</p><p>一是同胡适围绕“问题与主义”的论战；二是关于社会主义的论战，强调资本主义道路在中国走不通，中国的出路只能是社会主义；三是同无政府主义的论战，指出必须以革命的手段夺取政权，建立无产阶级政权。</p><p>7、简述中国共产党成立的伟大意义？（为什么说中国共产党的成立是一个“开天辟地的大事件”）</p><p>它标志着中国革命终于有了一个坚强的领导核心；中国革命从此有了一个科学的指导思想，即马克思主义；沟通了中国革命与世界革命的联系，使中国革命有了新的前途，即社会主义的前途。</p><p>8、简述中共“二大”的内容与意义？</p><p>1922年中共二大的召开，党的三大纲领：消除内战，达到军阀，建设国内和平；推翻国际帝国主义的压迫，达到中华民族完全独立；统一中国为真正的民主共和国。意义：中共二大在中国近代历史上第一次明确提出了反帝反封建的民主革命纲领，为中国革命指明了方向。</p><p>9、简述北伐战争得以胜利进军的原因？</p><p>国内合作的实现，革命统一战线的建立，特别是共产党员和共青团员的先锋模范作用是北伐胜利的重要原因；北伐军得到广大工农群众的大力支持；北伐战争得到了苏联政府的多方面援助。</p><p>10、简述国民革命失败的原因？</p><p>客观上，帝国主义和中国封建主义势力的联合力量大大超过了革命联合力量；革命统一战线内部出现剧烈分化，蒋介石、汪精卫先后分裂统一战线，制造反攻政策；主观上，以陈独秀为首的中共中央领导犯了右倾机会主义错误。</p><p>11、简述国民革命的历史意义？</p><p>沉重打击了帝国主义和封建主义的统治势力；扩大了中国共产党在中国人民中的政治影响，中国共产党正是从这场革命的失败中涉取教训，开始懂得了进行土地革命和掌握革命武装的重要性。</p><p><strong>第五章 中国革命的新道路</strong></p><p><strong>选择题：</strong></p><p>1、国民党实行的是代表地主阶级、买办性的大资产阶级利益的一党专政和军事独裁统治。</p><p>2、影响较大的中间党派的有：邓寅达的中国国民党临时行动委员会（又称第三党），乡村建设派，中华职业教育社，中国国家社会党。</p><p>3、中共中央确定土地革命和武装斗争的方针是在1927年的汉口会议中。“枪杆子里面出政权”的说法是由毛泽东首先提出的。</p><p>4、由大革命失败到土地革命战争兴起的历史转折点是八七会议。1927年毛泽东领到了秋收起义。</p><p>5、1927年8月1日的南昌起义是由周恩来、朱德、贺龙、叶挺、刘伯承发起的。1927年12月，张太雷、叶挺、叶剑英发动了广州起义。</p><p>6、中国共产党人对中国革命道路探索上，毛泽东有四篇代表作：《中国的红色政权为什么能够存在》、《井冈山的斗争》、《星星之火，可以燎原》（主要代表作）、《反对本本主义》。</p><p>7、新民主主义革命的基本问题是农民土地问题。</p><p>8、1931年成立的中华苏维埃共和国临时中央政府，当选为中央执行委员会主席的是毛泽东。</p><p>9、1936年红二、四方面军先后同红一方面军在甘肃会宁、静宁将台堡会师。</p><p><strong>简述题：</strong></p><p>1、为什么说国民党代表了大地主、大资产阶级的利益？</p><p>国民党政府是在帝国主义的支持下建立的，从根本上说，国民党统治的建立，并没有使中国摆脱帝国主义的压迫，而是为外国侵略势力深入中国进一步敞开了大门。国民党统治时期，在中国的社会经济生活中占优势地位的仍然是封建经济。国民党统治建立以后，官僚买办资本急剧的膨胀起来，它又是中国的垄断资本，控制了全国的经济命脉。国民党的反动统治代表着帝国主义、封建主义和官僚资本主义的利益，在当时，推翻国民党的反动统治成为新民主主义革命的主要目标。</p><p>2、简述中国国民党临时行动委员会及其政治主张？</p><p>委员会成立于1930年8月，一方面不满国民党当局的内外政策；一方面又错误的认为中国共产党的的革命主张不适合中国国情；同时还大力策动军事反蒋活动，商定武装起义计划，但其军事反蒋斗争，终因1931年邓寅达的被捕而告失败。</p><p>3、简述南昌起义的历史意义？</p><p>它打响了武装反抗国民党反动统治的第一枪；它成为共产党独立领导革命战争、创建人民军队和武装夺取政权的伟大开端；它揭开了土地革命战争的序幕。</p><p>4、“三湾改编”的主要内容及意义？</p><p>内容：将原有的一个师缩编成一个团；将党的支部建立在脸上；成立各级士兵委员会，部队内部实行民主管理。意义：它成为建设共产党领导的新型人民军队的重要开端。</p><p>5、试述红色政权存在和发展的原因和条件？</p><p>中国是一个几个帝国主义国家间接统治的政治经济发展极端不平衡的半殖民地半封建的大国（根本不原因）；国民革命的影响；全国革命形势的继续向前发展；相当力量的正式红军的存在；共产党组织的坚强有力和各项政策的正确贯彻执行。</p><p>6、简述“工农武装割据”的思想？</p><p>共产党领导的土地革命、武装斗争与根据地建设这三者之间的辩证统一关系。</p><p>7、简述土地革命中的阶级路线和土地分配方法？</p><p>依靠贫民、雇民，联合中农，限制富农，保护中小工商业者，消灭地主阶级；以乡为单位，按人口平分土地，在原耕地的基础上，实行抽多补少、抽肥补瘦。</p><p>8、试述王明“左”倾教条主义的主要错误？</p><p>在统一战线问题上一味排斥和打击中间势力；在革命道路问题上坚持以城市为中心；在土地革命问题上，实行消极防御的方针；在党内战争和组织问题上，推行“残酷斗争无情打击”方针。</p><p>9、简述中共党内屡次出现严重“左”倾错误的原因？</p><p>八七会议后，党内一直存在着的浓厚拼命的冲动；全党的马克思主义理论准备不足；共产国际的干预以及对王明的全力支持。</p><p>10、试述遵义会议及其重大意义？</p><p>1935年召开的遵义会议解决了当时具有决定意义的军事和组织问题。意义：遵义会议在及其危急的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，开始确立了以毛泽东为代表的新的中央的领导，成为中国共产党历史上一个生死攸关的转折点，标志着中国共产党在政治上走向成熟。</p><p>11、简述长征的伟大意义？</p><p>它粉碎了国民党“围剿”红军、消灭革命力量的企图；是中国革命转危为安的关建；它为迎接中国人民救亡的新高潮准备了条件；长征保存并锤炼了中国革命的骨干力量；长征播散了革命的火种；长征铸就了伟大的长征精神。</p><p><strong>第六章 中华民族的抗日战争</strong></p><p><strong>选择题：</strong></p><p>1、近代以来中国第一次取得反侵略完全胜利的战争是中国人民抗日战争。</p><p>2、中国人民抗日战争进入全民族抗战的新阶段是1937年的卢沟桥事变。</p><p>3、引发抗日战争的三大事变是1931年“九一八事变”、1935年“华北事变”、1937年“卢沟桥事变”。</p><p>4、标志着中国人民抗日救亡运动新高潮到来的是一二·九运动。</p><p>5、1935年在陕西召开的瓦窑堡会议提出了抗日统一战线的线政策。</p><p>6、1936年西安事变迫使蒋介石做出了停止“剿共”，成为时局转换的枢纽。</p><p>7、第二次国共合作作为基础的抗日民族统一战线正式建立的标志是共产党宣言和蒋介石的谈话。第二次国共合作时，红军主力改编为国民革命军第八路军，朱德任总指挥，彭德怀任副总指挥；南方的红军和游击队改编为国民革命军新编第四军，叶挺任军长，项英任副军长。</p><p>8、抗日战争时期中国始终存在着两个战场，即共产党领导的敌后战场和国民党领导的正面战场。</p><p>9、国民党的正面战场中的著名战役是1938年的台儿庄战役。</p><p>10、抗日战争中国民党著名的爱国将领有：佟麟阁、赵登属、谢晋元（淞沪会战）、张自忠（枣宜会战）、戴安澜。</p><p>11、战略相持阶段是中国抗日战争取得胜利的最关键的阶段。</p><p>12、抗日战争中，中国共产党军队取得胜利的第一个大胜战平型关大捷。</p><p>13、中国军队对日本军队发动的规模最大的战役是“百团大战”。</p><p>14、1941年，国民党发动的第二次反共高潮中最著名的事件是皖南事变。</p><p>15、为了坚持、扩大和巩固抗日民族统一战线，中国共产党制订了“发展进步实力，争取中间势力，孤立顽固势力”的总方针。抗日战争期间，进步势力是指工人、农民和城市小资产阶级。中间势力是指民族资产阶级、开明绅士和地方实力派。顽固势力是指大地主大资产阶级的抗日派，即以蒋介石集团为代表的国民党亲英美派。</p><p>16、抗日战争期间，共产党坚持的是“三三制”原则，即共产党员、非党的左派进步分子和中间派。抗日战争期间，土地政策施行的减租减息的政策。</p><p>17、整风运动的内容是反对主观主义以整顿学风、反对宗派主义以整顿党风、反对党八股以整顿文风。反对主观主义是整风运动的主要任务。主观主义的主要表现形式是教条主义和经验主义。中国共产党内出现“左”、右倾错误的思想认识根源是教条主义。</p><p>18、1945年，中共七大确立了以毛泽东为党的一切工作的指导思想。</p><p>19、1945年9月3日，抗日战争胜利。</p><p>20、1945年，中国成为联合国的创始国和五个常任理事国之一。</p><p><strong>简述题：</strong></p><p>1、简评抗日战争时期国民党领导的正面战场？</p><p>国民党领导的正面战场是抗日战争的重要战场；抗战初期，正面战场组织过若干重大战役，打破了日军“速战速决”的战略企图；随着相持阶段的到来，正面战场转化为比较消极，多次制造反共军事摩擦，在对日战场上连接出现溃败；国民党坚持独裁的政策也遭到全国人民的反对。</p><p>2、试述持久抗战的内容和意义？</p><p>内容：①毛泽东指出，中日战争不是任何别的战争，乃是版殖民的半封建的中国和帝国主义的日本之间在20世纪30年代进行的一个决战。中日双方存在着相互矛盾的四个特点：敌强我弱，敌小我大，敌退我进，敌寡助我多助；②毛泽东还科学的预测了抗日战争的发展阶段。即：抗日战争将经过战略防御、战略相持、战略反攻三个阶段；③它决定了抗日战争只能是持久战，最后胜利是属于中国的。意义：毛泽东阐明的持久战思想，抓住了中日战争发生的时代特点和战争性质，揭示了抗日战争的发展规律和坚持抗战、争取抗战胜利必须实行的战略方针，对全国抗战起了积极作用。</p><p>3、试述新民主主义革命的内容和意义？</p><p>内容：毛泽东阐明了中国共产党领导的整个中国革命运动是包括民主主义革命和社会主义革命两个阶段的全部革命运动。1919年五四运动以后的民主主义革命是新民主主义革命；他还阐明了中国共产党在新民主主义革命阶段的基本纲领，即政治、经济、文化上的纲领；他总结了中国共产党成立以来的经验，指出统一战线、武装斗争、党的建设，是中国共产党领带革命的三个基本问题，是战胜敌人的三个法宝。意义：新民主主义理论以毛泽东为主要代表的中国共产党人把马克思主义基本原理同中国革命具体实际相结合的理论成果，新民主义理论的系统阐明，标志着毛泽东思想达到成熟。</p><p>4、抗日战争胜利的意义？（为什么说中国人民抗日战争是近代以来中华民族反抗外敌入侵第一次取得完全胜利的民族解放战争？）</p><p>抗日战争的胜利，彻底打败了日本侵略者，捍卫了中国的国家主权和领土完整；抗日战争的胜利为中国共产党领导人民取得整个新民主主义革命的胜利奠定了基础；抗日战争的胜利促进了中华民族的大团结，弘扬了中华民族的伟大精神；抗日战争的胜利为最终战胜世界法西斯势力做出了历史性的贡献。</p><p>5、简述抗日战争胜利的原因？</p><p>共产党在全民族抗战中发挥了中流砥柱的作用；中国人民巨大的民族觉醒、空前的民族团结和英勇的民族抗战，是中国人民抗日战争胜利的决定性因素；中国人民抗日战争胜利，得到世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持也是分不开的。</p><p>6、抗日战争胜利的基本经验？</p><p>全国各族人民的大团结，是中国人民战胜一切艰难困苦、实现抗战胜利的力量源泉；以爱国主义为核心的伟大民族精神是中国人民团结奋进的精神动力；中国人民热爱和平，反对侵略战争，同时又不惧怕战争。</p><p>7、简述中国人民抗日战争在世界反法西斯战争中的地位？</p><p>抗日战争不仅是中华民族救亡图存的民族解放战争，也是世界反法西斯战争的重要组成部分；抗日战争是世界反法西斯战争的东方主战场；中国人民的持久战争为同盟军对完成太平洋战争的战略转折和实施战略反攻创造了有利条件。</p><p>8、为什么说中国共产党是中国人民抗日战争的中流砥柱？</p><p>中国共产党积极倡导、促成、维护抗日民族统一战线，最大限度地动员全国军民共同抗战，成为凝聚全民族力量的杰出组织者。以毛泽东为主要代表的中国共产人，把马克思列宁主义基本原理同中国具体实际相结合，科学阐明了抗日战争的规律和进程，制定了正确的战略和策略，对抗日战争发挥了重要的作用。</p><p><strong>第七章 为创建新中国而奋斗</strong></p><p><strong>选择题：</strong></p><p>1、共产党成立以后的四大战役是北伐战争、土地革命战争、抗日战争和解放战争。</p><p>2、1946年挑起全国性的内战的标志是以大局围攻中原解放区。</p><p>3、在国统区开展的爱国民主运动是配合人民解放战争的第二条战线。</p><p>4、人民解放战争开始的标志是1947年刘邓大军挺进大别山。</p><p>5、毛泽东提出的新民主主义革命的三大经济纲领是没收封建阶级的土地归农所有；没收垄断资本归新民主主义的国家所有；对民族工商业采取保护措施。</p><p>6、开始转变没收地主土地的标志是1946年中共中央发出的《关于清算、减租即土地问题的指示》（史称《五四指示》）。</p><p>7、中国共产党的土地改革总路线是依靠贫农，团结中农，有步骤的、又分别的消灭封建剥削制度，发展农业生产。</p><p>8、国统区人民斗争的高潮运动有昆明“一二·一”运动，抗暴运动,反饥饿、反内战、反迫害运动（五·二〇运动）。</p><p>9、中国最早宣告成立的自治区是内蒙古自治区。</p><p>10、中国各民主党派有中国国民党革命委员会（简称民革）；中国民主同盟（简称民盟）；中国民主建国会（简称民建）；中国民主促进会（简称民进）；中国农工民主党（简称工农党）；中国致公党（简称致公党）；九三学社；台湾民主自治同盟（简称台盟）。</p><p>11、“第三条道路”的幻想归于破灭的标志是民盟总部的解散。</p><p>12、中国共产党领导的多党合作制、政治协商格局形成于解放战争期间。</p><p>13、中华人民共和国成立前召开的最后一次会议是中共七届二中全会。</p><p><strong>简述题：</strong></p><p>1、简述抗日战争胜利以后的三种政治力量和三种建国方案？</p><p>一是地主阶级与买办性的大资产阶级的建国方案，此方案维护地主阶级和买办性的大资产阶级的根本利益；二是民族资产阶级的建国方案，此方案在中国行不通；三是工人阶级、农民阶级和城市小资产阶级的建国方案，此方案代表的是中国共产党，它希望建立一个工人阶级领导的、以工农联盟为基础的人民民主专政的人民共和国。</p><p>2、民族资产阶级的建国方案在中国行不通的原因？</p><p>一是帝国主义不容许中国成立一个独立、富强的资本主义国家；二是民族资产阶级在经济上、政治上的软弱性，使得它们没有勇气和能力去领导人民进行彻底反帝反封建的斗争，从而未建立资产阶级共和国扫清障碍。</p><p>3、如何理解毛泽东说“不但必须打败蒋介石，而且能够打败他”？</p><p>一是必须打败蒋介石是因为蒋介石发动的战争是一场在美帝国主义指挥下的反对中国民族独立和中国人民解放的反革命的战争。不用革命战争反对反革命战争，中国将变成黑暗的世界，中华民族的前途就会被断送；二是能够打败蒋介石，是因为蒋介石军事力量的优势和美国的援助，只是暂时的现象和临时起作用的因素。而蒋介石发动的战争的反人民性质，是人心的相背，则是经常性起作用的因素。</p><p>4、简述解放区经过土地政策出现的新面貌？</p><p>①广大农民对共产党更加信任和拥护，人民民主政权进一步巩固和加强；②广大农民从封建的生产关系中解放出来，生产积极性空前提高；③大批青壮年农民踊跃参军，配合解放军作战，人民解放战争有了巩固的后方和最基本的人力和物力保证。</p><p>5、试述国民党迅速走向崩溃的原因？</p><p>一是抗日胜利后，国民党把接受变成“劫收”，使民众期望破灭；二是国民党统治集团违背人民要求休养生息的意愿，实行反人民的内战政策；三是国民党统治集团将全国各阶层人民置于饥饿和死亡线上，迫使各阶层人民团结起来，同反动政府作斗争，除此以外，在无出路。</p><p>6、简述台湾少数民族地区的人民民主运动？</p><p>①1947年台湾的二二八起义；②1945年新疆省的“三区革命”；③1947年内蒙古自治政府宣告成立。</p><p>7、如何认识民主党派的历史意义？</p><p>一是重庆谈判期间，各民主党派同共产党一起反对国民党反动派的内战、独裁政策；二是在国民党发动全面内战时，民主党派同共产党保持一致；三是民主党派的许多成员积极参加共产党领导的爱国民主运动，有的为此流血牺牲；四是在人民解放战争转入战略反攻后各民主党派都公开宣言，站在人民革命一边。</p><p>8、简述七届二中全会的内容？</p><p>1949年3月，中国共产党在西柏坡村召开了七届二中全会。主要内容：一是规定了全国胜利后中国共产党在政治、经济、外交方面应当采取的基本政策；二是指出了中国有农业国转为工业国、有新民主主义社会转为社会主义的发展方向；三是在中国共产党自身建设的问题上，提出了“两个务必”的要求。</p><p>9、简述《论人民民主专政》的内容？</p><p>一是人民民主专政的基础是工农联盟；二是主要依靠工人阶级和农民阶级；三是为建立新中国，必须团结民族资产阶级；四是工人阶级领导的以工农联盟为基础的人民民主专政。</p><p>10、试述中国革命胜利的主要原因？</p><p>一是由于有了中国工人阶级的先锋队—中国共产党的领导；二是由于帝国主义、封建主义、官僚资本主义的残酷压迫，中国人民走上了反帝反封建反官僚主义斗争的伟大时代；三是中国革命之所以能够赢得胜利，同国际无产阶级和人民群众的支持也是分不开的。</p><p>11、简述中国革命胜利的基本经验？</p><p>一是建立广泛的统一战线；二是坚持革命的武装斗争；三是加强共产党自身的建设。</p><p>12、简述革命统一战线中的两个联盟及关系？</p><p>统一战线中存在着两个联盟：一个是劳动者的联盟，即工农联盟；一个是劳动者与非劳动者的联盟，主要是劳动者与民族资产阶级的联盟。 关系：这是辅助的、同时又是重要的。必须坚决依靠第一个联盟，争取建立和扩大第二个联盟。</p><p>13、为什么说“没有共产党就没有新中国”？</p><p>①中国共产党为工人阶级的政党，不仅代表着中国工人阶级的利益，而且代表着整个中华民族和全中国人民的利益；②中国共产党能够制定出适合中国情况的、符合中国人民利益的纲领、路线、方针和政策，为中国人民的斗争指明正确的方向。中国共产党人以行动表明了自己是最有远见、最富于牺牲精神，最坚定。而又最能虚心体察民情并依靠群众的坚强的革命者，从而赢得了广大中国人民的衷心拥护。</p><p><strong>第八章 社会主义基本制度的全面确立</strong></p><p><strong>选择题:</strong></p><p>1、西藏和平解放标志着中国大陆和平统一。</p><p>2、新中国的社会主义国营经济主要是通过没收官僚资本建立。</p><p>3、1950年七届三中全会，毛泽东的报告中指出要获得国家财政经济状况的根本好转，需要创造三个条件是指土地革命的完成，工商业的调整，国家机构经费的大量节俭。</p><p>4、“三反”运动是指反贪污、反浪费、反官僚主义。“五反”运动是指反行贿、反偷税漏税、反盗窃国家资财、反偷工减料、反盗窃国家经济情报。</p><p>5、1949年，第一个同中国建立外交关系的是苏联。</p><p>6、抗美援朝战争中，被任命为中国人民志愿军司令员兼政治委员的是彭德怀。</p><p>7、中国社会经济中存在着的五种成分分别是社会主义性质的国营经济，半社会主义性质的合作社经济，农民和手工业者的个性经济，私人资本主义经济和国家资本主义经济。</p><p>8、党在这个过渡时期的总路线的总任务，是实现“一化三改”即社会主义建设同社会主义改造的总路线。其主体是社会主义工业化。</p><p>9、对资本主义工商业进行社会主义改造是实行赎买政策，采取国家资本主义的形式，把资本主义工商业改造成为社会主义的。</p><p>10、国家资本主义经济是在人民政府管理之下，用各种形式和国营社会主义经济联系着，并受工人监督的资本主义经济。其初级形式是收购、加工、订货、统购、包销；高级形式是公私合营。</p><p><strong>简述题：</strong></p><p>1、为什么说新中国的成立是中国历史的新纪元？（新中国成立的伟大历史意义？）</p><p>一是帝国主义列强压迫中国、奴役中国人民的历史从此结束；二是宣告中国封建主义、官僚资本主义统治的历史从此结束；三是标志军阀割据。战乱频发、匪患不断的历史从此结束；四是从根本上改变了中国社会的发展历史；五是中国共产党成为全国范围内的执政党，总之，中华人民共和国的成立标志着中国的新民主主义革命取得胜利，标志着半殖民地半封建社会的结束和新民主主义社会的建立。</p><p>2、简述抗美援朝战争的意义？</p><p>抗美援朝的胜利，打击了美国的侵略和战争策略，保卫了新中国的安全，使全世界对中国刮目相看，新中国的国际威望空前提高拨，新中国的经济建设和社会改革赢得了一个相对稳定的和平环境。</p><p>3、简述新民主主义社会的特点和性质？</p><p>特点：新民主主义社会不是一个独立的社会形态，在经济上即有社会主义因素，又有资本主义因素；其性质具有过渡性。</p><p>4、为什么说通过社会主义道路实现国家工业化，这是最好的选择？</p><p>近代以来的历史表明，资本主义工业化的道路在中国是走不通的。从19世纪60年代末70年代初中国民族资本主义工业产生以来，由于受到外国垄断资本的压迫和本国封建生产关系的束缚，始终处于举步维艰的境地。在帝国主义时代，中国通过走资本主义道路实现现代化的可能性已经失去、。为了实现国家的工业化，中国必须走社会主义的道路。</p><p>5、为什么说过渡时期总路线反映了历史的必然？</p><p>一是社会主义工业化是国家独立和富强的必然要求和必要条件；二是资本主义经济力量弱小，发展困难，不可能成为中国工业起飞的基础；三是对个体农业进行社会主义改造，是保证工业发展、实现国家工业化的一个必要条件；四是当时的国际环境也促使中国选择社会主义。</p><p>6、试述一条有中国特点的社会主义的农业合作化道路？</p><p>一是在中国的条件下，可以走先合作化、后机械化的道路；二是通过互助组、初级社、高级社逐步过渡的方针；三是发展要坚持自愿和互利的原则；四是是否把增产作为衡量合作社是否办好的标准；五是把社会改造同技术改造相结合。</p><p>7、论述社会主义改造基本完成的意义？</p><p>一是社会主义改造的基本完成使社会主义的基本经济制度也建立起来了，是中国进入社会主义社会的主要标志；二是社会主义改造是由私有制到公有制的一场韦德的变革，使生产力从旧的生产关系束缚中解放出来，对生产力的发展直接起到了促进作用；三是通过社会主义改造，中国共产党创造性的完成了由新民主主义到社会主义的过渡，实现了中国历史上最伟大最深刻的社会变革，开始了中华民族伟大复兴的历史征程。</p><p><strong>第九章 社会主义建设在探索中曲折发展</strong></p><p><strong>选择题：</strong></p><p>1、毛泽东的《论十大关系》是共产党人开始探索社会主义建设道路的标志。</p><p>2、1961年中共提出的对国民经济实行的八字方针是“调整、巩固、充实、提高”。</p><p>3、1971年，文化大革命粉碎了江青、林彪两大反革命集团。</p><p>4、文化大革命的性质是一场由领导者错误发动，被反革命集团利用，给党、国家和各族人民带来严重灾难的内乱。</p><p>5、毛泽东的几大贡献：“二弹一星”的研制（1964年中国第一颗原子弹和1967年第一颗氢弹的爆发，1970年第一颗人造地球卫星的发射）；1971年中国恢复了在联合国的合法席位。</p><p>6、1972年中美建立外交关系。</p><p><strong>简述题：</strong></p><p>1、简述陈云提出的“三个主体、三个补充”的思想？</p><p>①国家经营是主体，个体经营为补充；②计划生产是主体，自由生产为补充；③国家市场是主体，自由市场为补充。</p><p>2、试述《关于正确处理人民内部矛盾的问题》的内容和意义？</p><p>内容：一是毛泽东提出要把正确处理人民内部矛盾作为国家政治生活的主题；二是毛泽东科学的分析了社会主义的基本矛盾仍然是生产力和生产关系、经济基础和上层建筑之间的矛盾。这些矛盾可以经过社会主义制度本身的自我调整和完善，不断地得到解决。这实际上为积极促进社会主义制度的自我完善和发展奠定了理论基石；三是毛泽东说社会主义社会存在着敌我之间和人民内部两类性质的矛盾，前者需要用专政的方法去解决，后者只能用民主的方法去解决。 意义：它是一篇重要的马克思主义文献，对中国社会主义事业具有长远的指导意义。</p><p>3、简述1957年的反右派斗争？</p><p>一是对极少数右派分子的进攻实行坚决反击，是完全正确和必要的；二是反右派斗争被严重的扩大化了。</p><p>4、简述1958年通过的“鼓足干劲、力争上游、多快好省的建设社会主义”的总路线？</p><p>一是反映了广大人民群众迫切要求改变国家经济文化落后状况的普遍愿望；二是其缺点是忽视了客观的经济规律。</p><p>5、如何认识错误的性质及其原因？</p><p>性质：中国共产党在全国建设社会主义时期所犯的严重错误，包括“文化大革命”在内，是探索中的错误，不是由社会主义制度本身所制造。原因：一是对于什么是社会主义、怎样建设社会主义的问题，还没有完全搞清楚；二是由于中国共产党把根本不属于阶级斗争的问题看做是阶级斗争，促成了阶级斗争的扩大化错误的产生；三是党的民主集中制和集体领导制度遭到严重破环，致使党无法依靠制度和集体的力量及时发现并纠正错误。</p><p>6、简述毛泽东等老一代革命家探索中国社会主义建设道路的理论贡献？</p><p>一是毛泽东论述了必须实行马克思主义与中国实际“第二次结合”的基本思想；二是提出了社会主义社会矛盾的学说；三是阐明了建设社会主义的基本方针。</p><p><strong>第十章 改革开放与现代化建设时期</strong></p><p><strong>选择题：</strong></p><p>1、历史决议评价毛泽东同志是伟大的马克思主义者，是伟大的无产阶级革命家、战略家和理论家。他的功绩是第一位的，错误是第二位的。</p><p>2、毛泽东思想是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经营总结，是中国共产党集体智慧的结晶。</p><p>3、邓小平提出的社会主义精神文明建设的根本任务是培养有理想、有道德、有文化、有纪律的社会主义公民。</p><p>4、1987年中共十三大提出了社会主义初级阶段的理论和“一个中心、两个基本点”的基本路线。</p><p>5、我国经济体制改革的目标是建立社会主义经济体制。</p><p>6、改革、发展和稳定的关系是：稳定是前提，改革是动力，发展是目的，三者相互促进。</p><p>7、2001年，中国正式加入世界贸易组织。</p><p>8、1997年7月1日香港回归，1999年12月20日澳门回归。</p><p>9、1998年，中共十五大提出的“三讲”是指讲学习、讲政治、讲正气。</p><p>10、科学发展观的核心是以人为本，基本要求是全面协调可持续，方法是统筹兼顾。</p><p>11、和谐社会的特征是指民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处。</p><p>12、社会主义核心价值体系的基本内容有马克思主义指导思想、中国特色社会主义共同理想、以爱国主义为核心的民族精神、以改革创新为核心的时代精神和社会主义荣辱观。</p><p>13、四位一体的内容有经济建设、政治建设、文化建设、社会建设。</p><p>14、和平发展的内涵：中国既通过争取和平的国际环境来发展自己，又通过自己的发展来促进世界和平。</p><p>15、新时期特点是改革开放，显著的成就是快速发展，突出的标志是与时俱进。</p><p>16、中国特色社会主义理论体系包括邓小平理论、“三个代表”重要思想和科学发展观。</p><p>17、20世纪以来，中国经历了三次历史性的巨大变化：一是辛亥革命，推翻了统治中国几千年的君主专制制度；、二是中华人民共和国的成立（1949年）和社会主义制度的建立（1956年）；三是改革开放（新时期）。</p><p><strong>简述题：</strong></p><p>1、为什么说中共十一届三中全会是新中国成立以来伟大的历史性转折？</p><p>1978年召开的中共十一届三中全会，一是冲破长期“左”的错误的严重束缚，否定了“两个凡是”的错误方针，评价了关于真理标准问题的讨论，否定“以阶级斗争为纲”的指导思想，作出了把工作重点转移到社会主义现代化建设上来和实行改革开放的战略决策，重新确立了马克思主义的思想路线、政治路线和组织路线；二是形成了以邓小平为核心的党的中央领导集体，以这次全会为起点，中国进入了改革开放和社会主义现代化建设的新时代。</p><p>2、论述社会主义的初级阶段的含义？</p><p>一是我国社会已经是社会主义社会；二是我国的社会主义社会还处在初级阶段。</p><p>3、简述“两个飞跃”的思想？</p><p>中国社会主义农业的改革和发展有两个飞跃：第一个飞跃是废除人民公社，实行家庭联产承包为主的责任制；第二个飞跃是发展集体经济。</p><p>4、简述“一个中国、两种制度”的构想？</p><p>在一个中国的前提下，国家的主体坚持社会主义制度，港澳台作为特别行政区保持原有的资本主义制度长期不变。</p><p>5、简述社会主义民主政治建设稳步推进的主要表现？</p><p>一是人民代表大会制度，中国共产党领导的多党合作和政治协商制度，进一步健全和完善，广泛的爱国统一战线继续得到巩固和发展；二是基层民主建设取得重大进展；三是社会主义法制建设取得显著成就，以宪法为基础的中国特色社会主义法律体系在逐步完备。</p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>中国近代史复习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（C语言版）期末复习整理</title>
    <url>/archives/27ff0a3a.html</url>
    <content><![CDATA[<!-- build time:Mon Dec 06 2021 20:38:19 GMT+0800 (中国标准时间) --><h3 id="第一章-数据结构概述"><a href="#第一章-数据结构概述" class="headerlink" title="第一章 数据结构概述"></a>第一章 数据结构概述</h3><h4 id="基本概念与术语"><a href="#基本概念与术语" class="headerlink" title="基本概念与术语"></a>基本概念与术语</h4><p>1． <strong>数据</strong>：数据是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被<br>计算机程序所处理的符号的总称。</p><ol start="2"><li><strong>数据元素</strong>：数据元素是数据的基本单位，是数据这个集合中的个体，也称之为元素，结点，顶点记录。<br>（补充：一个数据元素可由若干个 <strong>数据项</strong>组成。数据项是数据的不可分割的最小单位。）<br>3．数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。（有时候也<br>叫做属性。）<br>4． <strong>数据结构</strong>：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>（1）数据的逻辑结构：数据的逻辑结构是指数据元素之间存在的固有逻辑关系，常称为数<br>据结构。<br>数据的逻辑结构是从数据元素之间存在的逻辑关系上描述数据与数据的存储无关，是<br>独立于计算机的。<br>依据数据元素之间的关系，可以把数据的逻辑结构分成以下几种：</li><li><strong>集合</strong>：数据中的数据元素之间除了“同属于一个集合“的关系以外，没有其他关系。</li><li><strong>线性结构</strong>：结构中的数据元素之间存在“一对一“的关系。若结构为非空集合，则除了第<br>一个元素之外，和最后一个元素之外，其他每个元素都只有一个直接前驱和一个直接后继。</li><li><strong>树形结构</strong>：结构中的数据元素之间存在“一对多“的关系。若数据为非空集，则除了第一<br>个元素（根）之外，其它 每个数据元素都只有一个直接前驱，以及多个或零个 直<br>接后继。</li><li><strong>图状结构</strong>：（1）结构中的数据元素存在“多对多”的关系。若结构为非空集，折每个数据可有<br>多个（或零个）直接后继。<br>（2）数据的存储结构：数据元素及其关系在计算机内的表示称为数据的存储结构。<br>想要计算机处理数据，就必须把数据的逻辑结构映射为数据的存储结构。逻辑结构可以映射<br>为以下两种存储结构：<ol><li><strong>顺序存储结构</strong>：把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中，借助元素<br>在存储器中的相对位置来表示数据之间的逻辑关系。</li><li><strong>链式存储结构</strong>：借助指针表达数据元素之间的逻辑关系。不要求逻辑上相邻的数据元素物<br>理位置上也相邻。</li></ol></li><li><strong>时间复杂度分析</strong>：1.常量阶：算法的时间复杂度与问题规模 <strong>n 无关系</strong> T(n)=O(1)<br>2.线性阶：算法的时间复杂度与问题规模 <strong>n 成线性关系</strong> T(n)=O(n)<br>3.平方阶和立方阶：一般为 <strong>循环的嵌套</strong>，循环体最后条件为 i++<br>时间复杂度的大小比较：<br>O(1)&lt; O(log 2 n)&lt; O(n )&lt; O(n log 2 n)&lt; O(n2)&lt; O(n3)&lt; O(2 n )&lt;O(n!)&lt;O(n n)</li></ol><p>6.<strong>算法与程序</strong>：<br>（1）算法的 5 个特性<br>1、 输入：有零个或多个输入<br>2、 输出：有一个或多个输出<br>3、有穷性：要求序列中的指令是有限的；每条指令的执行包含有限的工作量；整个指令序<br>列的执行在有限的时间内结束。（程序与算法的区别在于，程序不需要有有穷性）<br>4、确定性：算法中的每一个步骤都必须是确定的，而不应当含糊、模棱两可。没有歧义。<br>5、可行性：算法中的每一个步骤都应当能被有效的执行，并得到确定的结果。<br>（2）.算法设计的要求：<br>1、正确性（达到预期效果，满足问题需求）<br>2、健壮性（能处理合法数据，也能对不合法的数据作出反应，不会产生不<br>可预期的后果）<br>3、可读性（要求算法易于理解，便于分析）<br>4、可修改可扩展性<br>5、高效率（较好的时空性能 ）<br>补充内容：<br>1、名词解释：数据结构、二元组<br>数据结构就是相互之间存在一种或多种特定关系的数据元素的集合。<br>二元组就是一种用来表示某个数据对象以及各个元素之间关系的有限集合。<br>2、根据数据元素之间关系的不同，数据的逻辑结构可以分为集合、线性结构、树形结构和<br>图状结构四种类型。<br>3、常见的数据存储结构一般有两种类型，它们分别是顺序存储结构、链式存储结构<br>6.在一般情况下，一个算法的时间复杂度是问题规模的函数<br>7.常见时间复杂度有：常数阶 O（1）、线性阶 O（n）、对数阶 O（log 2 n）、平方阶 O(n^2)、<br>指数阶 O(2^n)。通常认为，具有常数阶量级的算法是好算法，而具有指数阶量级的算法是<br>差算法。</p><h3 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h3><p>定义： <strong>线性表</strong>是 n 个数据元素的有限序列。 一个数据元素可由若干个 <strong>数据项</strong>组成。</p><ol><li>顺序表结构<br>线性表的顺序存储是指在内存中 <strong>用地址连续</strong>的一块存储空间顺序存放线性表的各元素，用这<br>种存储形式存储的线性表称为顺序表。</li><li>单链表<br>（1） 链表结点结构<br>线性表中的数据元素可以 <strong>用任意的一组存储单元</strong>来存储，用指针表示逻辑关系逻辑相邻的两<br>元素的存储空间可以是不连续的。<br>（2） 链表操作算法：初始化、插入、输出、删除、遍历<br><strong>初始化：p=(struct student <code>*</code>)malloc(sizeof(struct student));<br>插入： p-&gt;next=head-&gt;next; head-&gt;next=p;<br>输出：printf(“%d”,p-&gt;data);<br>删除：q=p-&gt;next; p-&gt;next = q-&gt;next ; free(q);<br>结点遍历： for(p=head;p;p=p-&gt;next);*</strong><br>补充内容：<br>1、线性表中，第一个元素没有直接前驱，最后一个元素没有直接后驱。<br>2、在一个单链表中，若 p 所指结点是 q 所指结点的前驱结点，则<strong>删除结点 q</strong> 的操作语句为<br><strong>P-&gt;next = q-&gt;next ; free(q);</strong><br>3、在长度为 N 的顺序表中，插入一个新元素平均需要移动表中 N/2 个元素，删除一个元素<br>平均需要移动（N-1）/2 个元素。<br>4、若线性表的主要操作是在最后一个元素之后插入一个元素或删除最后一个元素，则采用<br><strong>顺序表</strong>存储结构最节省运算时间。<br>5、已知顺序表中每个元素占用 3 个存储单元，第 13 个元素的存储地址为 336，则顺序表的<br>首地址为 300。（第 n 个元素的地址即首地址+(n-1)<em>每个元素的存储空间，如 a[12]（第 13<br>个元素）的地址=a[0]+12</em>3）<br>6、设有一带头结点单链表 L，请编写该单链表的初始化，插入、输出和删除函数。（函数名<br>自定义）<br>结点定义：</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype; <span class="comment">//结点数据类型，假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="comment">//结点结构</span></span><br><span class="line">datatype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">//双向链表还应加上*previous</span></span><br><span class="line">&#125; Lnode, * pointer ; <span class="comment">//结点类型,结点指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> pointer lklist; <span class="comment">//单链表类型，即头指针类型</span></span><br><span class="line"><span class="comment">//1.初始化：</span></span><br><span class="line"><span class="function">lklist <span class="title">initlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pointer head;</span><br><span class="line">head=<span class="keyword">new</span> node;<span class="comment">//这是 C++做法</span></span><br><span class="line"><span class="comment">//head=( pointer)malloc(sizeof(Lnode)); 这是 C 语言做法</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>; <span class="comment">//循环链表则是 head-&gt;next=head;</span></span><br><span class="line"><span class="comment">//双向链表应加上 head-&gt;previos=NULL;</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.插入：（C 语言中需要把 head 转化为全局变量才能实现此程序）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(lklist head,datatype x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">pointer q,s;</span><br><span class="line">q=<span class="built_in">get</span>(head,i<span class="number">-1</span>); <span class="comment">//找第 i-1 个点</span></span><br><span class="line"><span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="comment">//无第 i-1 点，即 i&lt;1 或 i&gt;n+1 时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;”非法插入位置!\n”; <span class="comment">//这是 C++做法，即 C 语言中的 printf(“非法插入位置!\n”);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">s=<span class="keyword">new</span> node;<span class="comment">//生成新结点 即 C 语言中的 s=( pointer)malloc(sizeof(Lnode));</span></span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=q-&gt;next; <span class="comment">//新点的后继是原第 i 个点</span></span><br><span class="line">q-&gt;next=s; <span class="comment">//原第 i-1 个点的后继是新点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.删除：（C 语言中需要把 head 转化为全局变量才能实现此程序）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(lklist head,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">pointer p,q;</span><br><span class="line">q=<span class="built_in">get</span>(head,i<span class="number">-1</span>); <span class="comment">//找待删点的直接前趋</span></span><br><span class="line"><span class="keyword">if</span>(q==<span class="literal">NULL</span> || q-&gt;next==<span class="literal">NULL</span>) <span class="comment">//即 i&lt;1 或 i&gt;n 时</span></span><br><span class="line">&#123;<span class="built_in">cout</span>&lt;&lt;”非法删除位置!\n”;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">p=q-&gt;next; <span class="comment">//保存待删点地址</span></span><br><span class="line">q-&gt;next=p-&gt;next; <span class="comment">//修改前趋的后继指针</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//释放结点 即 C 语言中的 free(p);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//删除成功</span></span><br></pre></td></tr></table></figure><ol><li>不带头结点的单链表 head 为空的判定条件是(A )<br>A. head=NULL B. head-&gt;next=NULL C. head-&gt;next=head D. head!=NULL</li><li>带头结点的单链表 head 为空的判定条件是(B )<br>A. head=NULL B. head-&gt;next=NULL C. head-&gt;next=head D. head!=NULL</li><li>在一个单链表中，若 p 所指结点不是最后结点，在 p 之后插入 s 所指结点，则执行(B )<br>A. s-&gt;next=p; p-&gt;next=s; B. s-&gt;next=p-&gt;next; p-&gt;next=s;<br>C. s-&gt;next=p-&gt;next; p=s; D. p-&gt;next=s; s-&gt;next=p;</li><li>在一个单链表中，若删除 p 所指结点的后续结点，则执行(A )<br>A. p-&gt;next=p-&gt;next-&gt;next;<br>B. p=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next;<br>C. p-&gt;next=p-&gt;next<br>D. p=p-&gt;next-&gt;next</li><li>从一个具有 n 个结点的有序单链表中查找其值等于 x 结点时，在查找成功的情况下，需<br>平均比较（B ）个结点。<br>A. n B. n/2 C. (n-1)/2 D. O(n ㏒ 2n)</li><li>给定有 n 个元素的向量，建立一个有序单链表的时间复杂度（B）<br>A.O(1) B.O(n) C.O(n2) D.O(n ㏒ 2n)<br>7.在一个具有 n 个结点的有序单链表中插入一个新结点并仍然有序的时间复杂度是(B)<br>A.O(1) B.O(n) C.O(n2) D.O(n ㏒ 2n)</li><li>在一个单链表中删除 q 所指结点时，应执行如下操作：<br>q=p-&gt;next;<br>p-&gt;next=( p-&gt;next-&gt;next );<br>free(q);//这种题目靠一根指针是没有办法完成的，必须要借助第二根指针。</li><li>在一个单链表中 p 所指结点之后插入一个 s 所指结点时，应执行：<br>s-&gt;next=( p-&gt;next )<br>p-&gt;next=(s)操作。</li><li>对于一个具有 n 个节点的单链表 ,在已知所指结点后插入一个新结点的时间复杂度是(O<br>（1）)；在给定值为 x 的结点后插入一个新结点的时间复杂度是（O(n)）。<br>11.问答题<br>线性表可用顺序表或链表存储。试问：<br>(1) 两种存储表示各有哪些主要优缺点?<br>顺序表的存储效率高，存取速度快。但它的空间大小一经定义，在程序整个运行期间不会发<br>生改变，因此，不易扩充。同时，由于在插入或删除时，为保持原有次序，平均需要移动一<br>半(或近一半)元素，修改效率不高。<br>链接存储表示的存储空间一般在程序的运行过程中动态分配和释放，且只要存储器中还有空<br>间，就不会产生存储溢出的问题。同时在插入和删除时不需要保持数据元素原来的物理顺序，<br>只需要保持原来的逻辑顺序，因此不必移动数据，只需修改它们的链接指针，修改效率较高。<br>但存取表中的数据元素时，只能循链顺序访问，因此存取效率不高。<br>(2) 若表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，<br>这时，应采用哪种存储表示？为什么？<br>应采用顺序存储表示。因为顺序存储表示的存取速度快，但修改效率低。若表的总数基本稳<br>定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，这时采用顺序存储表示<br>较好。</li></ol><h3 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h3><h4 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h4><h5 id="（1）-栈的结构与定义"><a href="#（1）-栈的结构与定义" class="headerlink" title="（1） 栈的结构与定义"></a>（1） 栈的结构与定义</h5><p>定义：限定仅在表尾进行插入或删除操作的线性表。<br>结构：<br>typedef struct list{<br>int listsize; //栈的容量<br>struct list *head; //栈顶指针<br>struct list *base; //栈底指针<br>}</p><h5 id="（2）-顺序栈操作算法："><a href="#（2）-顺序栈操作算法：" class="headerlink" title="（2） 顺序栈操作算法："></a>（2） 顺序栈操作算法：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配初始空间</span></span><br><span class="line">    S-&gt;base = (ElemType *) <span class="built_in">malloc</span>(Stack_Init_Size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S-&gt;base) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top = S-&gt;base; <span class="comment">/// 栈顶与栈底相同</span></span><br><span class="line">    S-&gt;stack_size = Stack_Init_Size; <span class="comment">// 栈的最大长度等于初始长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可</span></span><br><span class="line"><span class="function">Status <span class="title">EmptyStack</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;base == S-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度</span></span><br><span class="line"><span class="function">Status <span class="title">LengthStack</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Status) (S-&gt;top - S-&gt;base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶的元素，参数e用来存放栈顶的元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetTopStack</span><span class="params">(SqStack *S, ElemType *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    *e = *(S-&gt;top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进栈，参数e是要进栈的元素</span></span><br><span class="line"><span class="function">Status <span class="title">PushStack</span><span class="params">(SqStack *S, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若栈的最大长度不会够用时，重新开辟，增大长度</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top - S-&gt;base &gt;= S-&gt;stack_size) &#123;</span><br><span class="line">        S-&gt;base = (ElemType *)<span class="built_in">realloc</span>(S-&gt;base, (S-&gt;stack_size + StackIncrement) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S-&gt;base) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈顶指针为栈底指针加上栈之前的最大长度</span></span><br><span class="line">        S-&gt;top = S-&gt;base + S-&gt;stack_size;</span><br><span class="line">        <span class="comment">// 栈当前的最大长度等于栈之前的最大长度与增加的长度之和</span></span><br><span class="line">        S-&gt;stack_size += StackIncrement;</span><br><span class="line">    &#125;</span><br><span class="line">    *S-&gt;top++ = e; <span class="comment">// 先赋值，后栈顶指针上移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈，参数e用来存放出栈的元素</span></span><br><span class="line"><span class="function">Status <span class="title">PopStack</span><span class="params">(SqStack *S, ElemType *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;base == S-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = *--S-&gt;top; <span class="comment">// 栈顶指针先下移，后赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(S-&gt;base);</span><br><span class="line">    S-&gt;base = S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    S-&gt;stack_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历栈，依次打印每个元素</span></span><br><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(SqStack *S)</span> </span>&#123;</span><br><span class="line">    ElemType *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stack is NULL.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = S-&gt;top;</span><br><span class="line">    <span class="comment">// 由栈顶依次向下遍历</span></span><br><span class="line">    <span class="keyword">while</span> (p &gt; S-&gt;base) &#123;</span><br><span class="line">        p--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 链栈操作算法<br>结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">	 ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStack;</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造一个空栈，栈顶指针置为空 </span></span><br><span class="line">	S = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入栈：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S,ElemType e)</span></span>&#123;</span><br><span class="line">	    LinkStack p;<span class="comment">//定义p </span></span><br><span class="line">		p=<span class="keyword">new</span> StackNode;<span class="comment">//生成新结点 </span></span><br><span class="line">		p-&gt;data=e;<span class="comment">//e赋给新结点的数据域 </span></span><br><span class="line">		p-&gt;next=S; <span class="comment">//新结点插入栈顶 </span></span><br><span class="line">		S=p;<span class="comment">//修改栈顶指针为p</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">	LinkStack p;<span class="comment">//定义p </span></span><br><span class="line">	<span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;<span class="comment">//栈空 </span></span><br><span class="line">	e=S-&gt;data;<span class="comment">//将栈顶元素赋给e </span></span><br><span class="line">	p=S;<span class="comment">//p临时保存栈顶元素以备释放 </span></span><br><span class="line">	S=S-&gt;next;<span class="comment">//修改栈顶指针 </span></span><br><span class="line">	<span class="keyword">delete</span> p;<span class="comment">//释放空间 </span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h4><h5 id="（1）-队列的定义"><a href="#（1）-队列的定义" class="headerlink" title="（1） 队列的定义"></a>（1） 队列的定义</h5><p>定义：只允许在表的一端进行插入，而在另一端删除元素。</p><p>补充内容：<br>1、一个栈的入栈序列为“ABCDE”，则以下不可能的出栈序列是（B）<br>A. BCDAE B. EDACB C. BCADE D. AEDCB<br>2、栈的顺序表示中，用 TOP 表示栈顶元素，那么栈空的条件是（D）<br>A. TOP==STACKSIZE B. TOP==1 C. TOP==0 D. TOP==-1<br>3、允许在一端插入，在另一端删除的线性表称为队列。插入的一端为表头，删除的一端为<br>表尾。<br>4、栈的特点是先进后出，队列的特点是先进先出。<br>5、对于栈和队列，无论他们采用顺序存储结构还是链式存储结构，进行插入和删除操作的<br>时间复杂度都是 O(1)（即与已有元素 N 无关）。<br>6、已知链栈 Q，编写函数判断栈空，如果栈空则进行入栈操作，否则出栈并输出。（要求判<br>断栈空、出栈、入栈用函数实现）（详看考点 2）<br>7.出队与取队头元素的区别：出队就是删除对头的数据元素，取队头元素是获取对头的数据<br>元素值，不需要删除。<br>8.链栈与顺序栈相比，比较明显的优点是：（D）<br>A.插入操作比较容易 B.删除操作比较容易<br>C.不会出现栈空的情况 D.不会出现栈满的情况</p><p><strong>考点 1：队列的编程：</strong><br>结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> date;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">QueuePtr front;</span><br><span class="line">QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p>创建：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">InitQueue</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> (Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">EnQueue</span><span class="params">(LinkQueue Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">	 p=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    p-&gt;date=e;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;<span class="keyword">return</span> (Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">DeQueue</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;QueuePtr p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    e=p-&gt;date;</span><br><span class="line">    Q.front=p-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,e);</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)Q.rear=Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> (Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>考点 2：栈的编程：</strong><br>上述已有具体实现代码</p><h3 id="第四章-串-（不是重点内容）"><a href="#第四章-串-（不是重点内容）" class="headerlink" title="第四章 串 （不是重点内容）"></a>第四章 串 （不是重点内容）</h3><p>1.串是由零个或多个字符组成的有限序列<br>2.串的赋值：x=’abc’;或 x[ ]=’abc’;</p><h3 id="第五章-数组和广义表-（不是重点内容）"><a href="#第五章-数组和广义表-（不是重点内容）" class="headerlink" title="第五章 数组和广义表 （不是重点内容）"></a>第五章 数组和广义表 （不是重点内容）</h3><ol><li>多维数组中某数组元素的 position 求解。一般是给出数组元素的首元素地址和每个元素占<br>用的地址空间并组给出多维数组的维数，然后要求你求出该数组中的某个元素所在的位置。</li><li>明确 <strong>按行存储</strong>和 <strong>按列存储</strong>的区别和联系，并能够按照这两种不同的存储方式求解 1 中类<br>型的题。</li><li>将特殊矩阵中的元素按相应的换算方式存入数组中。这些矩阵包括：对称矩阵，三角矩<br>阵，具有某种特点的稀疏矩阵等。熟悉稀疏矩阵的三种不同存储方式： 三元组，带辅助行向<br>量的二元组， <strong>十字链表</strong>存储。掌握将稀疏矩阵的三元组或二元组向十字链表进行转换的算法。</li></ol><p>补充内容：<br>三元组：<br>结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="keyword">int</span> i,j; <span class="comment">//元素行下标及列下标int e; //元素值&#125;Triple;typedef struct&#123;int mu,nu,tu; //矩阵的行数、列数、非零元素个数Triple data[MAXSIZE+1]; //矩阵包含的三元组表，data[0]未用&#125;TSMatrix;</span></span><br></pre></td></tr></table></figure><p>十字链表：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>&#123;</span><span class="keyword">int</span> i,j; <span class="comment">//元素行下标及列下标int e; //元素值struct OLNode *right,*down; //行的后继以及列的后继&#125; OLNode，*OLink;typedef struct&#123;int mu,nu,tu; //矩阵的行数、列数、非零元素个数OLink *rhead,*chead; //行和列的表头指针组的首地址&#125;CrossList;CrossList Creat（CrossList M）&#123;int m,n,t;scanf(“%d%d%d”,&amp;m,&amp;n,&amp;t);M.mu=m;M.nu=n;M.tu=t;M.rhead=( OLink *)malloc((m+1)*sizeof(OLink)); //开辟行表头指针组M.chead=( OLink *)malloc((n+1)*sizeof(OLink)); //开辟行列头指针组M.rhead[]=M.chead[]=NULL; //初始化…… //接下来就是赋值和入链｝</span></span><br></pre></td></tr></table></figure><h3 id="第六章-树和二叉树"><a href="#第六章-树和二叉树" class="headerlink" title="第六章 树和二叉树"></a>第六章 树和二叉树</h3><h4 id="1．-树"><a href="#1．-树" class="headerlink" title="1． 树"></a>1． 树</h4><p><strong>（1） 树的概念及术语</strong><br><strong>树</strong> ：n（n≥0）个结点的有限集合。当 n＝0 时，称为空树；任意一棵非空树满足以下条件：<br>⑴ 有且仅有一个特定的称为根的结点；<br>⑵ 当 n＞1 时，除根结点之外的其余结点被分成 m（m&gt;0）个互不相交的有限集合<br>T1,T2,… ,Tm，其中每个集合又是一棵树，并称为这个根结点的子树。<br><strong>（2） 结点的度：</strong> 结点所拥有的子树的个数。<br>树的度：树中所有结点的度的最大值。<br><strong>（3） 叶子结点：</strong> 度为 0 的结点，也称为终端结点。<br>分支结点：度不为 0 的结点，也称为非终端结点。<br><strong>（4）孩子、双亲</strong> ：树中某结点的子树的根结点称为这个结点的孩子结点，这个结点称为它<br>孩子结点的双亲结点；<br>兄弟： 具有同一个双亲的孩子结点互称为兄弟。<br><strong>（5）路径：</strong> 如果树的结点序列 n1, n2, …, nk 有如下关系：结点 ni 是 ni+1 的双亲（1&lt;=i&lt;k），<br>则把 n1, n2, …, nk 称为一条由 n1 至 nk 的路径；路径上经过的边的个数称为路径长度。<br><strong>（6）祖先、子孙：</strong> 在树中，如果有一条路径从结点 x 到结点 y，那么 x 就称为 y 的祖先，<br>而 y 称为 x 的子孙。<br><strong>（7）结点所在层数：</strong> 根结点的层数为 1；对其余任何结点，若某结点在第 k 层，则其孩子<br>结点在第 k+1 层。<br>树的深度： 树中所有结点的最大层数，也称高度。<br><strong>（8）层序编号：</strong> 将树中结点按照从上层到下层、同层从左到右的次序依次给他们编以从 1<br>开始的连续自然数。<br><strong>（9）有序树、无序树：</strong> 如果一棵树中结点的各子树从左到右是有次序的，称这棵树为有序<br>树；反之，称为无序树。数据结构中讨论的一般都是有序树<br><strong>（10）</strong> 树通常有前序（根）遍历、后序（根）遍历和层序（次）遍历三种方式（树，<br>不是二叉树，没中序遍历。)</p><h4 id="2．-二叉树"><a href="#2．-二叉树" class="headerlink" title="2． 二叉树"></a>2． 二叉树</h4><p>（1）二叉树的定义：二叉树是 n（n≥0）个结点的有限集合，该集合或者为空集（称为空<br>二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉<br>树组成。</p><p>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在<br>同一层上。<br>（满二叉树的特点：叶子只能出现在最下一层；只有度为 0 和度为 2 的结点。）<br>完全二叉树：对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与<br>同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同。<br>完全二叉树的特点：<br>1.在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树。<br>2.叶子结点只能出现在最下两层，且最下层的叶子结点都集中在二叉树的左部；</p><ol start="3"><li>完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有左孩子。</li><li>深度为 k 的完全二叉树在 k-1 层上一定是满二叉树。</li></ol><p>（2）二叉树的性质：<br>性质 1：二叉树的第 i 层上最多有 2i-1 个结点（i≥1）。<br>性质 2： 一棵深度为 k 的二叉树中，最多有 2k-1 个结点，最少有 k 个结点。深度为 k<br>且具有 2k-1 个结点的二叉树一定是满二叉树<br>性质 3：在一棵二叉树中，如果叶子结点数为 n0，度为 2 的结点数为 n2，则有: n0＝n2<br>＋1。（一个结点的度就是指它放出的射线）<br>性质 4：具有 n 个结点的完全二叉树的深度为 log2n +1。<br>性质 5： 对一棵具有 n 个结点的完全二叉树中从 1 开始按层序编号，则对于任意的序<br>号为 i（1≤i≤n）的结点（简称为结点 i），有：<br>（1）如果 i＞1，则结点 i 的双亲结点的序号为 i/2；如果 i＝1，则结点 i 是根结点，无双<br>亲结点。<br>（2）如果 2i≤n，则结点 i 的左孩子的序号为 2i；如果 2i＞n，则结点 i 无左孩子。<br>（3）如果 2i＋1≤n，则结点 i 的右孩子的序号为 2i＋1；如果 2i＋1＞n，则结点 i 无右孩子。</p><h4 id="3．-二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）"><a href="#3．-二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）" class="headerlink" title="3． 二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）"></a>3． 二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）</h4><p>（1） 先序遍历</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XianXu</span><span class="params">(BiTree T)</span></span>&#123;<span class="keyword">if</span>(T)&#123;<span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data); <span class="comment">//先访问XianXu(T-&gt;lchild); //再继续遍历XianXu(T-&gt;rchild);&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>（2） 中序遍历<br>（3） 后序遍历</p><h4 id="4-森林与二叉树的转换"><a href="#4-森林与二叉树的转换" class="headerlink" title="4. 森林与二叉树的转换"></a>4. 森林与二叉树的转换</h4><p>（1）同级以左为亲，即左一结点的右孩子是与它同级的右一结点<br>（2）只认最左路线为亲子路线，即结点的左孩子是它下一级结点的最左的元素</p><h4 id="5-哈夫曼树"><a href="#5-哈夫曼树" class="headerlink" title="5. 哈夫曼树"></a>5. 哈夫曼树</h4><p>(1）哈夫曼树的基本概念：<br>哈夫曼树：给定一组具有确定权值的叶子结点， <strong>带权路径长度</strong>最小的二叉树。<br>(2）哈夫曼树的特点：</p><ol><li>权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。</li><li>只有度为 0（叶子结点）和度为 2（分支结点）的结点，不存在度为 1 的结点.<br>（3）哈夫曼树的构造算法思想及构造过程（森林与 哈夫曼编码）<br>就是求各权值和路径相乘之后叠加的最小值。</li></ol><p>1、已知一棵完全二叉树有 47 个结点，则该二叉树有（C）个叶子结点。<br>A. 6 B. 12 C. 24 D.48<br>解法如下：<br>1+2+4+8+16=31 计算从第一层到 n-1 层的结点个数<br>47-31=16 计算第 n 层的叶子结点个数<br>16-16/2=8 计算第 n-1 层的叶子结点个数<br>所以，叶子结点数=16+8=24 计算第 n 层和第 n-1 层的总叶子结点数<br>2、已知遍历一棵二叉树的前序序列 ABCDEFG 和中序序列 CBEDAFG，那么是下面哪棵树<br>（C ）。<br>C 图如下：<br>A<br>↙　 ↘<br>Ｂ　　　F<br>↙ 　↘ 　　　↘<br>C 　　　D 　　　　 G<br>↙<br>E<br>4、完全二叉树必须满足的条件为: ：一棵具有 n 个结点的二叉树，它的结构与满二叉树的<br>前 n 个结点的的结构相同。<br>5、哈夫曼树不存在度为 1 的结点。<br>6、有 5 个带权结点，其权值分别为 2，5，3，7，11，根据哈夫曼算法构建该树，并计算该<br>树的带权路径长度。（构建哈夫曼树，很简单，从小开始，计算相加，然后把所有叶子结点<br>乘以等级数字然后相加。也即是：带权路径长度=叶结点的权值<em>路径长度）<br>7.试找出分别满足下列条件的所有二叉树：<br>⑴ 前序序列和中序序列相同：*</em>只有右子树**<br>⑵ 中序序列和后序序列相同：<strong>只有左子树</strong><br>⑶ 前序序列和后序序列相同：<strong>只有根，空二叉树</strong></p><h3 id="第七章-图"><a href="#第七章-图" class="headerlink" title="第七章 图"></a>第七章 图</h3><h4 id="1-图的基本概念："><a href="#1-图的基本概念：" class="headerlink" title="1. 图的基本概念："></a>1. 图的基本概念：</h4><p>图的结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。<br>设图有 n 个顶点，则：<br>有 1/2 n(n-1)条边的无向图称为 <strong>完全图</strong><br>有 n（n-1）条弧的有向图称为 <strong>有向完全图</strong><br>元素被多少条弧的箭头所指，它的 <strong>入度</strong>就为多少；反之，出度。<br>第一个顶点和最后一个顶点相同的路径叫做 <strong>回路</strong>或<strong>环</strong> 环<br>顶点不重复出现的路径叫 <strong>简单路径</strong><br>若图中任意两个顶点之间存在路径（不一定是直接相连），则称作 <strong>连通图</strong>。</p><h4 id="2-邻接矩阵："><a href="#2-邻接矩阵：" class="headerlink" title="2. 邻接矩阵："></a>2. 邻接矩阵：</h4><p>．<br>W i,j &lt;V i ，V j &gt; ∈VR<br>邻接矩阵的定义： A[i][j]={<br>0 即 VR 中不存在 &lt;V i ，V j &gt;时</p><h4 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h4><p>（1）深度优先遍历<br>步骤：1.从任意顶点开始访问。<br>2.访问后把该元素对应的访问标志赋值为 1 表示已访问该数据元素<br>3.寻找与其有关未被访问的所有邻接顶点，并从该顶点开始进行访问</p><ol start="4"><li>重复 2、3 步骤直到该连通图的所有顶点均已访问完毕<br>（2）广度优先遍历<br>步骤：1.从任意顶点开始访问。<br>2.访问后把该元素对应的访问标志赋值为 1 表示已访问该数据元素<br>3.寻找与其有关未被访问的邻接顶点，并按顺序入列直到所有邻接顶点均<br>已访问完毕<br>4.把最先入列的顶点出列，以它为顶点开始访问</li><li>重复 2、3、4 步骤直到该连通图的所有顶点均已访问完毕</li></ol><h3 id="第八九十章"><a href="#第八九十章" class="headerlink" title="第八九十章"></a>第八九十章</h3><p>查找表<br>是由同一类型的数据元素（或记录）构成的集合<br>对查找表的操作有：<br>（1） 查询某个“特定的”数据元素是否在查找表中；<br>（2） 检索某个“特定的”数据元素的各种属性<br>（3） 在查找表中插入一个数据元素；<br>（4） 从查找表中删去某个特定元素<br>静态查找表<br>只进行前两种“查找”操作的查找表为静态查找表<br>动态查找表<br>若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某<br>个数据元素，则成为动态查找表<br>排序<br>其功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。</p><h3 id="既然都看到这了，码字不易，记得点赞收藏哦！！！"><a href="#既然都看到这了，码字不易，记得点赞收藏哦！！！" class="headerlink" title="既然都看到这了，码字不易，记得点赞收藏哦！！！"></a>既然都看到这了，码字不易，记得点赞收藏哦！！！</h3><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构（C语言版）期末复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现双向巡回链表</title>
    <url>/archives/c49a2ddd.html</url>
    <content><![CDATA[<!-- build time:Wed Dec 01 2021 19:37:41 GMT+0800 (中国标准时间) --><p>主要利用双向链表实现26个英文字母的循环输出</p><p>例如输入3，输入结果：</p><p>DEFGHIJKLMNOPQRSTUVWXYZABC</p><p>输入-3，则输出结果:</p><p>XYZABCDEFGHIJKLMNOPQRSTUVW</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*Linked;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(Linked *L)</span></span>&#123;<span class="comment">//初始化链表</span></span><br><span class="line">    Node *p,*q;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    *L = (Linked)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//生成一个指向头结点的指针</span></span><br><span class="line">    <span class="keyword">if</span>(!(*L))&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = (*L)-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">     p = (*L);<span class="comment">//p节点指向头结点，然后p在指向q，q在往后移动</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;<span class="comment">//添加26个英文字母</span></span><br><span class="line">        q = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//生成一个新节点，往里赋值，然后p指向q，</span></span><br><span class="line">                                         <span class="comment">//在生成新节点，以此循环</span></span><br><span class="line">        <span class="keyword">if</span>(!q)&#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;data = <span class="string">'A'</span>+i;</span><br><span class="line">        q-&gt;prior = p;</span><br><span class="line">        q-&gt;next = p-&gt;next;<span class="comment">//把q的next置为null</span></span><br><span class="line">        p-&gt;next = q;</span><br><span class="line"> </span><br><span class="line">        p=q;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//实现巡回的主要步骤</span></span><br><span class="line"> </span><br><span class="line">     p-&gt;next = (*L)-&gt;next; <span class="comment">//此时p，q都在最指的是最后一个节点，使p/q指向头结点的下一个节点</span></span><br><span class="line">     (*L)-&gt;next-&gt;prior=p;<span class="comment">//然后头结点的下一个节点在指回p/q。</span></span><br><span class="line">     (*L) = p;<span class="comment">//头结点在指向p/q</span></span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Casear</span><span class="params">(Linked *L,<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//打印输出链表</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            (*L) = (*L)-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(--i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line"> </span><br><span class="line">            (*L) = (*L)-&gt;prior;</span><br><span class="line">        &#125;<span class="keyword">while</span>(++i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linked L;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    InitList(&amp;L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个整数：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    Casear(&amp;L,n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言实现双向巡回链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的基本操作</title>
    <url>/archives/65ba9d2a.html</url>
    <content><![CDATA[<!-- build time:Mon Nov 29 2021 22:05:47 GMT+0800 (中国标准时间) --><h2 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h2><h3 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h3><p>通过该实验，让学生掌握二叉树的相关基本概念，理解二叉树的链式存储，掌握二叉树的几种遍历算法，并通过该实验理解递归的含义，掌握C语言编写递归函数的方法和注意事项。</p><h3 id="2-实验主要仪器、设备和材料等"><a href="#2-实验主要仪器、设备和材料等" class="headerlink" title="2.实验主要仪器、设备和材料等"></a>2.实验主要仪器、设备和材料等</h3><p>硬件：PC机</p><p>软件：Dev-C++、VC 6.0或CodeBlocks等。</p><h3 id="3-实验内容（包括实验原理和操作步骤）"><a href="#3-实验内容（包括实验原理和操作步骤）" class="headerlink" title="3.实验内容（包括实验原理和操作步骤）"></a>3.实验内容（包括实验原理和操作步骤）</h3><ol><li><p>按照先序遍历的顺序创建一个二叉链表；</p></li><li><p>对已建立的二叉树实现先序遍历、中序遍历、后序遍历、求深度、求结点数量等操作。</p></li><li><p>最好用菜单形式对应各个操作，使其编程一个完整的小软件。</p><p><strong>测试用例：</strong></p><p><img data-src="../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/01.png" alt></p></li></ol><ul><li><p>创建</p></li><li><p>输入：ABC##DE#G##F###</p></li><li><p>该输入对应的树如上图所示</p></li><li><p>先序 屏幕输出 A B C D E G F</p></li><li><p>中序 屏幕输出 C B E G D F A</p></li><li><p>后序 屏幕输出 C G E F D B A</p></li><li><p>深度 屏幕显示 深度为5</p></li><li><p>结点数量 屏幕显示 结点数量为7</p></li><li><p>销毁 销毁后的二叉树再进行遍历等操作会提示二叉树未创建。</p></li></ul><h3 id="参考界面："><a href="#参考界面：" class="headerlink" title="参考界面："></a>参考界面：</h3><p><img data-src="../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/02.png" alt></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct BitNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct BitNode *lchild,*rchild;</span><br><span class="line">&#125;BitNode,*BiTree;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建二叉树</span><br><span class="line">void CreateBiTree(BiTree &amp;T)&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    if(ch&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">         T&#x3D;NULL;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        T&#x3D;new BitNode;</span><br><span class="line">        T-&gt;data&#x3D;ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);</span><br><span class="line">        CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;先序遍历</span><br><span class="line">void PreOrderTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">void InOrderTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;后序遍历</span><br><span class="line">void PostTraverse(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line"></span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求二叉树的深度</span><br><span class="line">int Depth(BiTree T)&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    if(T&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        m&#x3D;Depth(T-&gt;lchild);</span><br><span class="line">        n&#x3D;Depth(T-&gt;rchild);</span><br><span class="line">        if(m&gt;n)&#123;</span><br><span class="line">            return (m+1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (n+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;统计二叉树节点的数量</span><br><span class="line">int NodeCount(BiTree T)&#123;</span><br><span class="line">    if(T&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;销毁二叉树</span><br><span class="line">void DestroyBitree(BiTree T)&#123;</span><br><span class="line">    if(T)&#123;</span><br><span class="line">        DestroyBitree(T-&gt;lchild);</span><br><span class="line">        DestroyBitree(T-&gt;rchild);</span><br><span class="line">        free(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int code;</span><br><span class="line">	int flag&#x3D;0;</span><br><span class="line">	BiTree T&#x3D;NULL;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">	system(&quot;cls&quot;);</span><br><span class="line">	printf(&quot;**********************************************************\n&quot;);</span><br><span class="line">	printf(&quot;****                  ****系统菜单****                ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  1.创建二叉树                  *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  2.先序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  3.中序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  4.后序遍历二叉树              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  5.求二叉树的深度              *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  6.求二叉树的节点数量          *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  7.销毁二叉树                  *    ****\n&quot;);</span><br><span class="line">	printf(&quot;****            *  8.退出                        *    ****\n&quot;);</span><br><span class="line">	printf(&quot;**********************************************************\n&quot;);</span><br><span class="line">		printf(&quot;请输入操作代码:&quot;);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;code);</span><br><span class="line">		getchar();</span><br><span class="line">		switch(code)</span><br><span class="line">		&#123;</span><br><span class="line">		case 1:</span><br><span class="line">			&#123;</span><br><span class="line">			    printf(&quot;请输入二叉树元素（‘#’表示为空）\n&quot;);</span><br><span class="line">			    CreateBiTree(T);</span><br><span class="line">                printf(&quot;二叉树创建成功\n&quot;);</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		case 2:</span><br><span class="line">			&#123;</span><br><span class="line">                if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;先序遍历后:\n&quot;);</span><br><span class="line">                PreOrderTraverse(T);</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">		    &#125;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		case 3:</span><br><span class="line">                if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;中序遍历后:\n&quot;);</span><br><span class="line">                    InOrderTraverse(T);</span><br><span class="line">                    printf(&quot;\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">		    break;</span><br><span class="line">		case 4:</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    printf(&quot;先序遍历后:\n&quot;);</span><br><span class="line">                PostTraverse(T);</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		    break;</span><br><span class="line">		case 5:</span><br><span class="line">		    int deep;</span><br><span class="line">            if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                deep&#x3D;Depth(T);</span><br><span class="line">                printf(&quot;二叉树的深度为：%d\n&quot;,deep);</span><br><span class="line">		    &#125;</span><br><span class="line">			break;</span><br><span class="line">		case 6:</span><br><span class="line">		    int num;</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                num&#x3D;NodeCount(T);</span><br><span class="line">                printf(&quot;二叉树的节点数量为：%d\n&quot;,num);</span><br><span class="line">		    &#125;</span><br><span class="line">		    break;</span><br><span class="line">		case 7:</span><br><span class="line">		    if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;二叉树未创建\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                DestroyBitree(T);</span><br><span class="line">                flag&#x3D;0;</span><br><span class="line">                printf(&quot;二叉树已被销毁\n&quot;,num);</span><br><span class="line">		    &#125;</span><br><span class="line">		    break;</span><br><span class="line">		case 8:</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;程序结束!\n&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		default:printf(&quot;数据无效，请重新输入!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		system(&quot;pause&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>实现二叉树的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>不规则动词总结表</title>
    <url>/archives/c07a60bb.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><p>​</p><h1 id="英语不规则动词总结表"><a href="#英语不规则动词总结表" class="headerlink" title="英语不规则动词总结表"></a><center>英语不规则动词总结表</center></h1><h2 id="一、AAA型（原形→原形→原形）"><a href="#一、AAA型（原形→原形→原形）" class="headerlink" title="一、AAA型（原形→原形→原形）"></a>一、AAA型（原形→原形→原形）</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>read</td><td>read</td><td>read</td><td>读</td></tr><tr><td>cut</td><td>cut</td><td>cut</td><td>切，割</td></tr><tr><td>let</td><td>let</td><td>let</td><td>让</td></tr><tr><td>put</td><td>put</td><td>put</td><td>放</td></tr><tr><td>cost</td><td>cost</td><td>cost</td><td>花费，值</td></tr><tr><td>hit</td><td>hit</td><td>hit</td><td>撞，击</td></tr><tr><td>set</td><td>set</td><td>set</td><td>安排，安置</td></tr><tr><td>hurt</td><td>hurt</td><td>hurt</td><td>使…伤痛</td></tr><tr><td>bet</td><td>bet</td><td>bet</td><td>赌博，打赌</td></tr><tr><td>cast</td><td>cast</td><td>cast</td><td>抛</td></tr></tbody></table><h2 id="二、ABA型（原形→过去式→原形）"><a href="#二、ABA型（原形→过去式→原形）" class="headerlink" title="二、ABA型（原形→过去式→原形）"></a>二、ABA型（原形→过去式→原形）</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>become</td><td>became</td><td>become</td><td>成为</td></tr><tr><td>come</td><td>came</td><td>come</td><td>来</td></tr><tr><td>run</td><td>ran</td><td>run</td><td>跑</td></tr></tbody></table><h2 id="三、ABC型"><a href="#三、ABC型" class="headerlink" title="三、ABC型"></a>三、ABC型</h2><h3 id="1-ow-→ew-→own"><a href="#1-ow-→ew-→own" class="headerlink" title="1. ow →ew →own"></a>1. ow →ew →own</h3><table><thead><tr><th align="left">原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td align="left">blow</td><td>blew</td><td>blown</td><td>吹</td></tr><tr><td align="left">draw</td><td>drew</td><td>drawn</td><td>画</td></tr><tr><td align="left">grow</td><td>grew</td><td>grown</td><td>生长</td></tr><tr><td align="left">know</td><td>knew</td><td>known</td><td>知道</td></tr><tr><td align="left">throw</td><td>threw</td><td>thrown</td><td>扔</td></tr></tbody></table><h3 id="2-i→a-→u"><a href="#2-i→a-→u" class="headerlink" title="2. i→a →u"></a>2. i→a →u</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>begin</td><td>began</td><td>begun</td><td>开始</td></tr><tr><td>drink</td><td>drank</td><td>drunk</td><td>喝</td></tr><tr><td>sing</td><td>sang</td><td>sung</td><td>唱</td></tr><tr><td>swim</td><td>swam</td><td>swum</td><td>游泳</td></tr><tr><td>ring</td><td>rang</td><td>rung</td><td>打电话</td></tr></tbody></table><h3 id="3-原形→过去式→过去式-e-n"><a href="#3-原形→过去式→过去式-e-n" class="headerlink" title="3. 原形→过去式→过去式+(e)n"></a>3. 原形→过去式→过去式+(e)n</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>wear</td><td>wore</td><td>worn</td><td>穿</td></tr><tr><td>forget</td><td>forgot</td><td>forgotten</td><td>忘记</td></tr><tr><td>speak</td><td>spoke</td><td>spoken</td><td>说</td></tr><tr><td>freeze</td><td>froze</td><td>frozen</td><td>冻</td></tr><tr><td>choose</td><td>chose</td><td>chosen</td><td>选择</td></tr></tbody></table><h3 id="4-原形→过去式→原形-e-n"><a href="#4-原形→过去式→原形-e-n" class="headerlink" title="4. 原形→过去式→原形+(e)n"></a>4. 原形→过去式→原形+(e)n</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>eat</td><td>ate</td><td>eaten</td><td>吃</td></tr><tr><td>forbid</td><td>forbade</td><td>forbidden</td><td>禁止</td></tr><tr><td>give</td><td>gave</td><td>given</td><td>给</td></tr><tr><td>ride</td><td>rode</td><td>ridden</td><td>骑</td></tr><tr><td>see</td><td>saw</td><td>seen</td><td>看见</td></tr><tr><td>write</td><td>wrote</td><td>written</td><td>写</td></tr><tr><td>fall</td><td>fell</td><td>fallen</td><td>落下</td></tr><tr><td>break</td><td>broke</td><td>broken</td><td>打破，折断</td></tr><tr><td>forgive</td><td>forgave</td><td>forgiven</td><td>原谅；宽恕</td></tr><tr><td>drive</td><td>drove</td><td>driven</td><td>驾驶</td></tr><tr><td>mistake</td><td>mistook</td><td>mistaken</td><td>误解</td></tr><tr><td>rise</td><td>rose</td><td>risen</td><td>上升</td></tr><tr><td>shake</td><td>shook</td><td>shaken</td><td>摇</td></tr></tbody></table><h3 id="5-无规律"><a href="#5-无规律" class="headerlink" title="5. 无规律"></a>5. 无规律</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>am/is</td><td>was</td><td>been</td><td>是</td></tr><tr><td>are</td><td>were</td><td>been</td><td>是</td></tr><tr><td>do</td><td>did</td><td>done</td><td>做</td></tr><tr><td>go</td><td>went</td><td>gone</td><td>走</td></tr><tr><td>take</td><td>took</td><td>taken</td><td>拿</td></tr></tbody></table><h2 id="四、ABB型"><a href="#四、ABB型" class="headerlink" title="四、ABB型"></a>四、ABB型</h2><h3 id="1-原形→ought-→ought"><a href="#1-原形→ought-→ought" class="headerlink" title="1. 原形→ought →ought"></a>1. 原形→ought →ought</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>bring</td><td>brought</td><td>brought</td><td>带来</td></tr><tr><td>buy</td><td>bought</td><td>bought</td><td>买</td></tr><tr><td>fight</td><td>fought</td><td>fought</td><td>打架</td></tr><tr><td>think</td><td>thought</td><td>thought</td><td>思考</td></tr><tr><td>seek</td><td>sought</td><td>sought</td><td>寻求</td></tr></tbody></table><h3 id="2-原形→aught-→aught"><a href="#2-原形→aught-→aught" class="headerlink" title="2. 原形→aught →aught"></a>2. 原形→aught →aught</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>catch</td><td>caught</td><td>caught</td><td>捉,抓</td></tr><tr><td>teach</td><td>taught</td><td>taught</td><td>教</td></tr></tbody></table><h3 id="3-变其中一个元音字母"><a href="#3-变其中一个元音字母" class="headerlink" title="3.变其中一个元音字母"></a>3.变其中一个元音字母</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>feed</td><td>fed</td><td>fed</td><td>喂</td></tr><tr><td>meet</td><td>met</td><td>met</td><td>遇见</td></tr><tr><td>get</td><td>got</td><td>got</td><td>得到</td></tr><tr><td>hold</td><td>held</td><td>held</td><td>拥有</td></tr><tr><td>babysit</td><td>babysat</td><td>babysat</td><td>临时照看</td></tr><tr><td>sit</td><td>sat</td><td>sat</td><td>坐</td></tr><tr><td>win</td><td>won</td><td>won</td><td>赢</td></tr><tr><td>find</td><td>found</td><td>found</td><td>发现</td></tr><tr><td>bend</td><td>bent</td><td>bent</td><td>使弯曲</td></tr><tr><td>dig</td><td>dug</td><td>dug</td><td>挖</td></tr><tr><td>lead</td><td>led</td><td>led</td><td>引导</td></tr><tr><td>sell</td><td>sold</td><td>sold</td><td>卖</td></tr><tr><td>retell</td><td>retold</td><td>retold</td><td>复述</td></tr></tbody></table><h3 id="4-原形→□t→□t"><a href="#4-原形→□t→□t" class="headerlink" title="4. 原形→□t→□t"></a>4. 原形→□t→□t</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>feel</td><td>felt</td><td>felt</td><td>感到</td></tr><tr><td>keep</td><td>kept</td><td>kept</td><td>保持</td></tr><tr><td>leave</td><td>left</td><td>left</td><td>离开</td></tr><tr><td>sleep</td><td>slept</td><td>slept</td><td>睡</td></tr><tr><td>sweep</td><td>swept</td><td>swept</td><td>扫</td></tr><tr><td>smell</td><td>smelt</td><td>smelt</td><td>闻；发出气味</td></tr></tbody></table><h3 id="5-变其中一个辅音字母"><a href="#5-变其中一个辅音字母" class="headerlink" title="5.变其中一个辅音字母"></a>5.变其中一个辅音字母</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>build</td><td>built</td><td>built</td><td>建造</td></tr><tr><td>hear</td><td>heard</td><td>heard</td><td>听见</td></tr><tr><td>make</td><td>made</td><td>made</td><td>制造</td></tr><tr><td>mean</td><td>meant</td><td>meant</td><td>意思</td></tr><tr><td>send</td><td>sent</td><td>sent</td><td>送,寄</td></tr><tr><td>spend</td><td>spent</td><td>spent</td><td>花费</td></tr><tr><td>deal</td><td>dealt</td><td>dealt</td><td>处理</td></tr><tr><td>rebuild</td><td>rebuilt</td><td>rebuilt</td><td>重建</td></tr><tr><td>lend</td><td>lent</td><td>lent</td><td>借贷</td></tr></tbody></table><h3 id="6-辅音字母和元音字母都变"><a href="#6-辅音字母和元音字母都变" class="headerlink" title="6.辅音字母和元音字母都变"></a>6.辅音字母和元音字母都变</h3><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>have</td><td>had</td><td>had</td><td>有,吃</td></tr><tr><td>lay</td><td>lain</td><td>lain</td><td>放</td></tr><tr><td>lose</td><td>lost</td><td>lost</td><td>丢失</td></tr><tr><td>pay</td><td>paid</td><td>paid</td><td>付钱</td></tr><tr><td>say</td><td>said</td><td>said</td><td>说</td></tr><tr><td>sell</td><td>sold</td><td>sold</td><td>卖</td></tr><tr><td>tell</td><td>told</td><td>told</td><td>告诉</td></tr><tr><td>stand</td><td>stood</td><td>stood</td><td>站</td></tr><tr><td>misunderstand</td><td>misunderstood</td><td>misunderstood</td><td>误解</td></tr><tr><td>shoot</td><td>shot</td><td>shot</td><td>放炮；开枪</td></tr><tr><td>understand</td><td>understood</td><td>understood</td><td>理解</td></tr></tbody></table><h2 id="五、AAB型"><a href="#五、AAB型" class="headerlink" title="五、AAB型"></a>五、AAB型</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th align="center">汉语意思</th></tr></thead><tbody><tr><td>beat</td><td>beat</td><td>beaten</td><td align="center">打败</td></tr></tbody></table><h2 id="六、有两种形式"><a href="#六、有两种形式" class="headerlink" title="六、有两种形式"></a>六、有两种形式</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>bear</td><td>bore</td><td>born</td><td>生</td></tr><tr><td>bore</td><td>borne</td><td></td><td></td></tr><tr><td>hang</td><td>hanged</td><td>hanged</td><td>吊死</td></tr><tr><td>hung</td><td>hung</td><td>挂</td><td></td></tr><tr><td>learn</td><td>learned</td><td>learned</td><td>学</td></tr><tr><td>learnt</td><td>learnt</td><td></td><td></td></tr><tr><td>lie</td><td>lied</td><td>lied</td><td>说谎</td></tr><tr><td>lay</td><td>lain</td><td>躺</td><td></td></tr><tr><td>show</td><td>showed</td><td>showed</td><td>给……看</td></tr><tr><td>showed</td><td>shown</td><td></td><td></td></tr><tr><td>spell</td><td>spelled</td><td>spelled</td><td>拼写</td></tr><tr><td>spelt</td><td>spelt</td><td></td><td></td></tr><tr><td>burn</td><td>burned</td><td>burned</td><td>烧</td></tr><tr><td>burnt</td><td>burnt</td><td></td><td></td></tr><tr><td>smell</td><td>smelled</td><td>smelled</td><td>闻</td></tr><tr><td>smelt</td><td>smelt</td><td></td><td></td></tr><tr><td>shine</td><td>shined</td><td>shined</td><td>照耀</td></tr><tr><td>shone</td><td>shone</td><td></td><td></td></tr><tr><td>dream</td><td>dreamed</td><td>dreamed</td><td>做梦</td></tr><tr><td>dreamt</td><td>dreamt</td><td></td><td></td></tr><tr><td>wake</td><td>waked</td><td>waked</td><td>醒</td></tr><tr><td>woke</td><td>woken</td><td></td><td></td></tr><tr><td>hide</td><td>hid</td><td>hid</td><td>躲藏</td></tr><tr><td>hid</td><td>hidden</td><td></td><td></td></tr><tr><td>bite</td><td>bit</td><td>bit</td><td>咬</td></tr><tr><td>bit</td><td>bitten</td><td></td><td></td></tr><tr><td>light</td><td>lighted</td><td>iighted</td><td>点着</td></tr><tr><td>lit</td><td>lit</td><td></td><td></td></tr><tr><td>prove</td><td>proved</td><td>proved</td><td>证明</td></tr><tr><td>proved</td><td>proven</td><td></td><td></td></tr><tr><td>quit</td><td>quit</td><td>quit</td><td>放弃</td></tr><tr><td>quited</td><td>quited</td><td></td><td></td></tr><tr><td>rid</td><td>rid</td><td>rid</td><td>免除；去掉</td></tr><tr><td>ridded</td><td>ridded</td><td></td><td></td></tr><tr><td>saw</td><td>sawed</td><td>sawed</td><td>锯</td></tr><tr><td>sawed</td><td>sawn</td><td></td><td></td></tr><tr><td>sew</td><td>sewed</td><td>sewed</td><td>缝纫</td></tr><tr><td>sewed</td><td>sown</td><td></td><td></td></tr><tr><td>shine</td><td>shone</td><td>shone</td><td>发光；闪亮</td></tr><tr><td>shined</td><td>shined</td><td></td><td></td></tr><tr><td>sink</td><td>sank</td><td>sunk</td><td>下沉</td></tr><tr><td>sank</td><td>sunken</td><td></td><td></td></tr><tr><td>sow</td><td>sowed</td><td>sowed</td><td>种植</td></tr><tr><td>sowed</td><td>sown</td><td></td><td></td></tr><tr><td>spit</td><td>spat</td><td>spat</td><td>吐</td></tr><tr><td>spit</td><td>spit</td><td></td><td></td></tr><tr><td>spring</td><td>sprang</td><td>sprung</td><td>跳跃</td></tr><tr><td>sprung</td><td>sprung</td><td></td><td></td></tr><tr><td>wet</td><td>wet</td><td>wet</td><td>浸湿；弄湿</td></tr><tr><td>wetted</td><td>wetted</td><td></td><td></td></tr></tbody></table><h2 id="七、情态动词"><a href="#七、情态动词" class="headerlink" title="七、情态动词"></a>七、情态动词</h2><table><thead><tr><th>原形</th><th>过去式</th><th>过去分词</th><th>汉语意思</th></tr></thead><tbody><tr><td>can</td><td>could</td><td>∕</td><td>能</td></tr><tr><td>may</td><td>might</td><td>∕</td><td>也许</td></tr><tr><td>must</td><td>∕</td><td>∕</td><td>必须</td></tr><tr><td>shall</td><td>should</td><td>∕</td><td>将要</td></tr><tr><td>will</td><td>would</td><td>∕</td><td>会</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>不规则动词总结表</tag>
      </tags>
  </entry>
  <entry>
    <title>高数公式</title>
    <url>/archives/29c7973.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h1 id="高数数学所有公式总结"><a href="#高数数学所有公式总结" class="headerlink" title="高数数学所有公式总结"></a>高数数学所有公式总结</h1><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_1.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_2.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_3.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_4.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_5.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_6.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_7.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_8.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_9.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_10.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_11.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_12.png" alt></p><p><img data-src="../images/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F_13.png" alt></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>高数公式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中$event的用法——如何获取当前兄弟元素，子元素，父元素</title>
    <url>/archives/378703a1.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tempalte&gt;</span><br><span class="line"></span><br><span class="line">   &lt;button @click = “getEvent($event)”&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">      methods:&#123;</span><br><span class="line"></span><br><span class="line">         getEvent(e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// e.target 是你当前点击的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// e.currentTarget 是你绑定事件的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           #获得点击元素的前一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.innerHTML</span><br><span class="line"></span><br><span class="line">           #获得点击元素的第一个子元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.firstElementChild</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的下一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.nextElementSibling</span><br><span class="line"></span><br><span class="line">           # 获得点击元素中id为string的元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getElementById(<span class="string">"string"</span>)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的string属性</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getAttributeNode(<span class="string">'string'</span>)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的父级元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.parentElement</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的前一个元素的第一个子元素的HTML值</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.firstElementChild.innerHTML</span><br><span class="line"></span><br><span class="line">         &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Jsp中的session</title>
    <url>/archives/fdcf16bb.html</url>
    <content><![CDATA[<!-- build time:Mon Dec 06 2021 20:32:43 GMT+0800 (中国标准时间) --><p>Jsp中的session</p><p>1.什么是session:<br>当用户打开浏览器，访问某个网站的时候，服务器就会在服务器的内存为该浏览器分配一个内存空间，该空间被这个浏览器独占，这个空间就是session空间。<br>该空间中的数据默认存在时间为30min,可以修改(session.setMaxInactiveInterval(int seconds))</p><p>2.session可以用来做什么？<br>（1）可以用作网上商城的购物车<br>（2）保存登录用户的信息<br>（3）将某些数据放在session中，供同一用户的各个页面使用（共享数据）<br>（4）防止用户非法登录到某个页面</p><p>3.session的使用：<br>（1）得到session<br>servlet中：HttpSession hs = request.getSession(true);<br>jsp中:session是一个内置对象，可以直接使用<br>(2)向session添加属性：<br>servlet中：hs.setAttribute(String name,Object value)<br>jsp中：session.setAttribute(String name,Object value)<br>(3)从session得到某个属性：<br>servlet中：hs.getAttribute(String name)<br>jsp中：session.getAttribute(String name)<br>(4)从session中删除某个属性：<br>servlet中:hs.removeAttribute(String name)<br>jsp中:hs.removeAttribute(String name)</p><p>4.session注意事项：<br>（1）session默认存在时间是30分钟，在tomcat的web.xml中的<session-out>可以修改<br>（2）上述默认时间指的是“发呆时间”，不是累计时间，就是不访问它的时间超过30分钟就会被回收，期间访问了它的话这个时间就会重新计算<br>（3）当某个浏览器访问服务器时，服务器会给它一个唯一的session id,通过id来区分不痛的浏览器<br>（4）因为session要占用服务器内存，因此在迫不得已的情况下才使用（一般使用：保存用户信息，保存购物车）</session-out></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>解决eclipse端口被占用</title>
    <url>/archives/969da7de.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h4 id="解决eclipse端口被占用"><a href="#解决eclipse端口被占用" class="headerlink" title="解决eclipse端口被占用"></a>解决eclipse端口被占用</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-801d15d118d7c3e5.png" alt="5640239-801d15d118d7c3e5.png"></p><p>问题如图所示，在eclipse中开启tomcat服务器时报错：端口已被占用。</p><p>这是因为在tomcat开启的状态下，eclipse异常关闭，导致tomcat一直占用端口。<br>解决办法如下：</p><p>1： 输入命令netstat -ano|findstr “8080”，查看8080端口是否被占用，且得到了进程号“13384”；</p><p>2： 再输入命令tasklist|findstr “13384”，得到进程映像名javaw.exe；</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-779a4d67255f5cfb.png" alt="5640239-779a4d67255f5cfb.png"></p><p>3： 启动任务管理器，结束javaw.exe进程；</p><ul><li>用鼠标打开任务管理器，首先鼠标放在电脑最下边靠右边的任务栏上，点击右键</li></ul><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-16874fe86025821b.png" alt="5640239-16874fe86025821b.png"></p><p>选择启动任务管理器，用鼠标左键单击，就打开了任务管理器</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-a6d975126589654c.jpg" alt="5640239-a6d975126589654c.jpg"></p><p>找到13384所对应的程序，结束任务</p><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-390417a76c06c5c7.png" alt="5640239-390417a76c06c5c7.png"></p><ol start="4"><li>最后再输入命令netstat -ano|findstr “8080”，查看8080端口是否被还占用</li></ol><p><img data-src="https://upload-images.jianshu.io/upload_images/5640239-dbccc1732c77b015.png" alt="5640239-dbccc1732c77b015.png"></p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>eclipse端口被占用解决办法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue获取节点总结</title>
    <url>/archives/a8f7bb1e.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="vue获取各个节点的方式"><a href="#vue获取各个节点的方式" class="headerlink" title="vue获取各个节点的方式"></a>vue获取各个节点的方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tempalte&gt;</span><br><span class="line"></span><br><span class="line">   &lt;button @click &#x3D; “getEvent($event)”&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   export default &#123;</span><br><span class="line"></span><br><span class="line">      methods:&#123;</span><br><span class="line"></span><br><span class="line">         getEvent(e) &#123;</span><br><span class="line"></span><br><span class="line">            console.log(e)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; e.target 是你当前点击的元素</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; e.currentTarget 是你绑定事件的元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           #获得点击元素的前一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.innerHTML</span><br><span class="line"></span><br><span class="line">           #获得点击元素的第一个子元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.firstElementChild</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的下一个元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.nextElementSibling</span><br><span class="line"></span><br><span class="line">           # 获得点击元素中id为string的元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getElementById(&quot;string&quot;)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的string属性</span><br><span class="line"></span><br><span class="line">           e.currentTarget.getAttributeNode(&#39;string&#39;)</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的父级元素</span><br><span class="line"></span><br><span class="line">           e.currentTarget.parentElement</span><br><span class="line"></span><br><span class="line">           # 获得点击元素的前一个元素的第一个子元素的HTML值</span><br><span class="line"></span><br><span class="line">           e.currentTarget.previousElementSibling.firstElementChild.innerHTML</span><br><span class="line"></span><br><span class="line">         &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue获取节点总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库总结</title>
    <url>/archives/3086330.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-如何在命令行配置MYSQL数据库"><a href="#1-如何在命令行配置MYSQL数据库" class="headerlink" title="1.如何在命令行配置MYSQL数据库"></a>1.如何在命令行配置MYSQL数据库</h3><p>1）找到MYSQL安装目录的bin目录</p><p>2）放置到path环境变量中</p><h3 id="2-启动停止MYSQL"><a href="#2-启动停止MYSQL" class="headerlink" title="2.启动停止MYSQL"></a>2.启动停止MYSQL</h3><p>启动： netstarmysqla 停止：mysql net stop mysqla</p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>binary,int,float,double,char,varchar,text,datetime</p><h3 id="4-添加数据库"><a href="#4-添加数据库" class="headerlink" title="4.添加数据库"></a>4.添加数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="5-查看数据库"><a href="#5-查看数据库" class="headerlink" title="5.查看数据库"></a>5.查看数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">show create database;</span><br></pre></td></tr></table></figure><h3 id="6-删除数据"><a href="#6-删除数据" class="headerlink" title="6.删除数据"></a>6.删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="7-使用数据库前需要先打开数据表所在的数据库"><a href="#7-使用数据库前需要先打开数据表所在的数据库" class="headerlink" title="7.使用数据库前需要先打开数据表所在的数据库"></a>7.使用数据库前需要先打开数据表所在的数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><h3 id="8-创建表"><a href="#8-创建表" class="headerlink" title="8.创建表"></a>8.创建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名(字段1 类型（长度）,[约束]，.....);</span><br></pre></td></tr></table></figure><h3 id="9-查询当前数据库下有哪些表"><a href="#9-查询当前数据库下有哪些表" class="headerlink" title="9.查询当前数据库下有哪些表"></a>9.查询当前数据库下有哪些表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables</span><br></pre></td></tr></table></figure><h3 id="10-查询表结构"><a href="#10-查询表结构" class="headerlink" title="10.查询表结构"></a>10.查询表结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sesc student</span><br></pre></td></tr></table></figure><h3 id="11-数据库备份与还原"><a href="#11-数据库备份与还原" class="headerlink" title="11.数据库备份与还原"></a>11.数据库备份与还原</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump-uroot-p first-db&gt;C:123456.sql</span><br></pre></td></tr></table></figure><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>1.数据库没有大小写之分</p><p>2.关键词大写，自定义的小写<br>3.修改表内容的关键词</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 （动作）</span><br><span class="line">改表名 动作 rename 新表名</span><br><span class="line">改字段类型 动作 modify 字段名 新类型</span><br><span class="line">改字段名称 动作 change 旧名称 新名称 新类型</span><br><span class="line">增加字段 动作 add 新增字段名 新增字段类型</span><br><span class="line">删除字段 动作 drop 字段名</span><br><span class="line">删除表 drop table 表名;</span><br><span class="line">删除数据库 drop database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="1、数据完整性"><a href="#1、数据完整性" class="headerlink" title="1、数据完整性"></a>1、数据完整性</h3><p>主键约束 primary key 特点是非空且唯一<br>两种写法，直接写在字段后，或者写在创建语句最后 primary key（字段名）<br>联合主键 写在创建语句最后 primary key(字段 1，字段 2)</p><h3 id="2、设置字段自增长-auto-increment"><a href="#2、设置字段自增长-auto-increment" class="headerlink" title="2、设置字段自增长 auto_increment"></a>2、设置字段自增长 auto_increment</h3><p>数据表只有一个自增长列，为主键列</p><h3 id="3、外键约束-foreign-key"><a href="#3、外键约束-foreign-key" class="headerlink" title="3、外键约束 foreign key"></a>3、外键约束 foreign key</h3><p>写在创建语句最后 foreign key (从表字段名) references 主表名<br>（主表字段名）</p><h3 id="4、非空约束-not-null"><a href="#4、非空约束-not-null" class="headerlink" title="4、非空约束 not null"></a>4、非空约束 not null</h3><h3 id="5、默认约束-default-值，注意字符串，需外加单引号"><a href="#5、默认约束-default-值，注意字符串，需外加单引号" class="headerlink" title="5、默认约束 default 值，注意字符串，需外加单引号"></a>5、默认约束 default 值，注意字符串，需外加单引号</h3><h3 id="6、唯一约束-unique"><a href="#6、唯一约束-unique" class="headerlink" title="6、唯一约束 unique"></a>6、唯一约束 unique</h3><p>主键约束和唯一约束的区别，主键无意义，唯一约束可以为 null<br>设计规范<br>1NF（第一范式）保证数据列的原子性<br>家庭住址 可分为省 市 县 具体地址<br>2NF 保证每列都和主键相关（唯一主键，联合主键不满足）<br>学号 姓名 课程 教材 教材内容<br>1 张三 数据库 mysql XXXXX（1 千字）<br>1 张三 java java<br>2 李四 数据库 mysql XXXXX（1 千字）<br>3 王五 数据库 mysql XXXXX（1 千字）<br>数据冗余 更新异常 插入异常 删除异常</p><p>3NF 保证每列都和主键直接相关<br>学号 姓名 班级 辅导员编号 辅导员姓名 辅导员家庭住址</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="数据库的增删改操作"><a href="#数据库的增删改操作" class="headerlink" title="数据库的增删改操作"></a>数据库的增删改操作</h3><h3 id="1、插入数据"><a href="#1、插入数据" class="headerlink" title="1、插入数据"></a>1、插入数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名（列 1，列 2，。。。） values（值 1，值 2，。。。）；</span><br><span class="line">查询数据</span><br><span class="line">select * from 表名;</span><br></pre></td></tr></table></figure><h3 id="2、into-关键字可以省略"><a href="#2、into-关键字可以省略" class="headerlink" title="2、into 关键字可以省略"></a>2、into 关键字可以省略</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简写形式 insert 表名（列 1，列 2，。。。） values（值 1，值 2，。。。）；</span><br></pre></td></tr></table></figure><h3 id="3、全列插入可省略列明"><a href="#3、全列插入可省略列明" class="headerlink" title="3、全列插入可省略列明"></a>3、全列插入可省略列明</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简写形式 insert 表名 values（值 1，值 2，。。。）；</span><br></pre></td></tr></table></figure><h3 id="4、自增列和默认列可省略"><a href="#4、自增列和默认列可省略" class="headerlink" title="4、自增列和默认列可省略"></a>4、自增列和默认列可省略</h3><p>注意：自增列只增不减<br>除非：alter table 表名 set auto_increment=值;<br>或者 truncate table 表名; 清空表，自增从 1 开始记数</p><h3 id="5、一次插入多行"><a href="#5、一次插入多行" class="headerlink" title="5、一次插入多行"></a>5、一次插入多行</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert 表名（列 1，列 2，。。。） values（值 1，值 2，。。。），（值 1，</span><br><span class="line">值 2，。。。），。。。。；</span><br></pre></td></tr></table></figure><h3 id="6、比较运算"><a href="#6、比较运算" class="headerlink" title="6、比较运算"></a>6、比较运算</h3><p>大于&gt;=大于等于&lt;小于&lt;=小于等于 =等于 !=或&lt;&gt;不等于</p><p>is null 为空 is not null 非空 in 在某个范围 not in 不在某个范<br>围 like 模糊查询 between and 在某个范围</p><h3 id="7、逻辑运算"><a href="#7、逻辑运算" class="headerlink" title="7、逻辑运算"></a>7、逻辑运算</h3><p>not 非 and 并且 or 或者</p><h3 id="8、修改数据"><a href="#8、修改数据" class="headerlink" title="8、修改数据"></a>8、修改数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 列名 1&#x3D;值 1，列名 2&#x3D;值 2… where 条件;</span><br></pre></td></tr></table></figure><p>如果没有 where 全更新</p><h3 id="9、删除数据"><a href="#9、删除数据" class="headerlink" title="9、删除数据"></a>9、删除数据</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 条件;</span><br></pre></td></tr></table></figure><p>注意删除数据不更改自增列的值</p><h3 id="10、清空数据"><a href="#10、清空数据" class="headerlink" title="10、清空数据"></a>10、清空数据</h3><p>truncate table 表名功能同 delete from 表名<br>但是<br>1&gt;Delete 无法修改自增列，truncate 重置自增列<br>2&gt;Delete 可以删除外键约束，truncate 只能清空数据，无法删除外<br>键约束<br>3&gt;Delete 可以通过备份和日子恢复，truncate 无法恢复</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><strong>注意：</strong><br>1、数据库没有双引号，字符一定要用单引号包括<br>2、字段名不用引号，单引号包括的一定是字符<br>``(数字键 1 左边的键)</p><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>select 字段 1、字段 2… from 表名 where 条件 order by 字段 1、<br>字段 2.. limit 数字 1,数字 2;<br>*是通配符，表示所有字段<br>使用 as 为字段重命名</p><h3 id="3、where-查询条件"><a href="#3、where-查询条件" class="headerlink" title="3、where 查询条件"></a>3、where 查询条件</h3><h3 id="4、distinct-查询不重复字段"><a href="#4、distinct-查询不重复字段" class="headerlink" title="4、distinct 查询不重复字段"></a>4、distinct 查询不重复字段</h3><h3 id="5、limit-n-m"><a href="#5、limit-n-m" class="headerlink" title="5、limit n,m"></a>5、limit n,m</h3><p>从 n+1 行开始取，取 m 行，行数从 0 开始<br>limit n,取前 n 行</p><h3 id="6、order-by-字段-1"><a href="#6、order-by-字段-1" class="headerlink" title="6、order by 字段 1"></a>6、order by 字段 1</h3><p>通过字段 1 将表从小到大排列<br>order by 字段 1 desc<br>order by 字段 1,字段 2<br>先按照字段 1 排列，在字段 1 相同的情况下按照字段 2 排列</p><p>成绩表，姓名，成绩<br>查询一下第 3 到 6 的女学生姓名<br>select 姓名 from 成绩表 where 性别=’女’ order by 成绩 desc<br>limit 2,4;<br>MySQL 函数<br>concat(‘今天’,’晴天’) 拼接字符串<br>length(‘hello world’) 计算长度，一个字符，符号，数字占 1 位，<br>一个汉字占 3 位<br>upper(‘abcd’) 转成大写<br>ltrim(‘ abc’) 清除左侧空格<br>rtrim(‘abc ‘) 清除右侧空格<br>trim(‘ abc ‘) 清除两侧空格<br>replace(‘abccd’,’c’,’x’) 将 abccd 中的所有 c 替换成 x<br>strcmp(‘a’,’b’) 比较字符串大小<br>substring(‘abcdefg’,3,3) 取子串，从第 3 个开始取，取 3 个<br>数学函数<br>rand(); 取 0~1 的随机小数，取不到 0 和 1<br>ceil();向上取整<br>floor(); 向下取整</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="模糊查询和分组查询"><a href="#模糊查询和分组查询" class="headerlink" title="模糊查询和分组查询"></a>模糊查询和分组查询</h3><p>模糊查询使用 like 关键字， _代表一个字符 ，%代表任意长度的字<br>符（0 也是任意长度）<br>between and 关键字，表示大于等于第一个数，小于等于第二个数<br>select * from stuinfo where age between 18 and 20;where age &gt;=18 and age&lt;=20;<br>聚合函数<br>求和 sum，平均 avg，最大 max，最小 min，个数 count(<em>)使用聚合函数只有一行结果分组查询group by 写在 where 后面，order by 前面select \</em> from stuinfo group by age;只有聚合函数和被分组的列有意义使用 having 对分组结果进行条件查询，写在 group by 后面P43 count(*)和 count(列名)<br>count(列名)，如果列里面是 null 的，不计入总数</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>数据库有3中连接方式（MySQL有），其他数据库如（Oracle，SQL Server）<br>有 4 中包括全连接</p><h3 id="1、内连接"><a href="#1、内连接" class="headerlink" title="1、内连接"></a>1、内连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1，表 2 WHERE 条件</span><br></pre></td></tr></table></figure><p>另一种写法</p><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 INNER JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="2、左连接"><a href="#2、左连接" class="headerlink" title="2、左连接"></a>2、左连接</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 LEFT JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="3、右连接"><a href="#3、右连接" class="headerlink" title="3、右连接"></a>3、右连接</h3><p>​</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名 1,列名 2… FROM 表 1 RIGHT JOIN 表 2 ON 条件</span><br></pre></td></tr></table></figure><h3 id="4、全连接"><a href="#4、全连接" class="headerlink" title="4、全连接"></a>4、全连接</h3><p>先左连接再右连接</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA面向对象总结</title>
    <url>/archives/4732fab1.html</url>
    <content><![CDATA[<!-- build time:Thu Nov 19 2020 09:56:34 GMT+0800 (GMT+08:00) --><h2 id="第二章：类和对象的创建"><a href="#第二章：类和对象的创建" class="headerlink" title="第二章：类和对象的创建"></a>第二章：类和对象的创建</h2><p>概念：面向对象就是把一个项目，一个事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。</p><p>好处：面相对象更接近实物的本质，提高代码的复用更具有扩展性。</p><p>如何使用：通常是创建类的对象再给属性赋值。</p><p>构造方法：构造方法的名称和类名相同，没有返回值类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO g&#x3D;new GO();</span><br></pre></td></tr></table></figure><p>构造方法的重载：方法名相同，参数列表不同，这是构造方法的重载。</p><p>如果一个类中包含了两个或两个以上的方法，他们方法名相同，方法参数个数或者参数类型不同，则称该方法被重载了，这个过程是方法重载。</p><p>Static：可以用来修饰属性，方法和代码块，静态方法中不能使用this和super关键字。</p><h2 id="第三章：封装"><a href="#第三章：封装" class="headerlink" title="第三章：封装"></a>第三章：封装</h2><p>概念：封装指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>好处：提高了安全性 提高了复用性 提高了实现细节</p><p>注意事项：类的属性中均用private来修饰 定义geter和seter方法</p><h2 id="第四章：继承"><a href="#第四章：继承" class="headerlink" title="第四章：继承"></a>第四章：继承</h2><p>概念：比如FeiGe快递系统中有三个实体类Person（人），Courier（快递员）,Customer（客户）类，Courier,Customer都属于（派生类）Person，所以都继承（extends）自Person类。</p><p>好处：提高了代码的重用性 提高了代码的扩展性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：class 类名 extends父接口&#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;属性定义</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;方法定义&#125;</span><br></pre></td></tr></table></figure><p>注意事项：1.子类继承父类所以的属性和方法，只不过只能调用非Private属性和方法2.java中的继承只支持单继承，意思是一个子类只能继承一个父类，但是允许多层继承</p><p>继承中的构造方法：调用父类中的构造方法，</p><p>需用到关键字super super指代父类</p><p>重写的概念：在继承的关系中。子类会自动继承父类中定义的方法，但有时子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：void 方法名（）&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意事项：子类重写父类的方法时，不能使用比父类中被重写的方法更严格的访问权限，重写方法和被重写方法必须具有相同的方法名，相同的参数列表和相同的返回值类型，重写方法的访问修饰符必须大于被重写方法的访问修饰符，否则就不能被称为方法的重写。</p><p>异常的处理：在程序执行代码的时候万一发生了异常，程序会按照预定的处理方法对异常进行处理，异常处理完毕之后，程序继续运行。</p><h3 id="语法：5个关键字-try-catch-finally-throw-throws"><a href="#语法：5个关键字-try-catch-finally-throw-throws" class="headerlink" title="语法：5个关键字 try catch finally throw throws"></a>语法：5个关键字 try catch finally throw throws</h3><p>常见的异常类型</p><p>Exception 异常层次的根类 ArithmeticException 算术错误情形，如以零作除数</p><p>ArrayIndexOutOfBoundsException 数组下标越界</p><p>NullPointerException空指针异常</p><p>ClassNotFoundException不能加载所需的类</p><p>InputMismatchException得到的数据类型与实际输入的类型不匹配</p><p>llegalArgumentException方法接收到非法参数</p><p>ClassCastException对象强制类型转换出错</p><p>NumberFormatException数字格式转换异常，如把“abc”转换成数字</p><h2 id="第五章：多态"><a href="#第五章：多态" class="headerlink" title="第五章：多态"></a>第五章：多态</h2><p>概念：指允许不同类的对象对同一消息做出响应即同同一消息可以根据发送对象的不同而采用多种不同的行为方式。</p><p>好处：可替换性 可扩充性 接口性 灵活性 简化性</p><p>多态的使用：</p><p>子类向父类转换称为向上转型</p><h3 id="向上转型：-lt-父类型-gt-lt-引用变量名-gt-new-lt-子类型-gt-（）；"><a href="#向上转型：-lt-父类型-gt-lt-引用变量名-gt-new-lt-子类型-gt-（）；" class="headerlink" title="向上转型：&lt;父类型&gt;&lt;引用变量名&gt;=new&lt;子类型&gt;（）；"></a>向上转型：&lt;父类型&gt;&lt;引用变量名&gt;=new&lt;子类型&gt;（）；</h3><p>将一个指向子类对象的父类引用赋给一个子类的引用，即将父类类型转换子类类型，称为向下转型，此时必须进行强制类型转换。</p><h3 id="向下转型：-lt-子类型-gt-lt-引用变量名-gt-（-lt-子类型-gt-）-lt-父类型的引用变量-gt-；"><a href="#向下转型：-lt-子类型-gt-lt-引用变量名-gt-（-lt-子类型-gt-）-lt-父类型的引用变量-gt-；" class="headerlink" title="向下转型：&lt;子类型&gt;&lt;引用变量名&gt;=（&lt;子类型&gt;）&lt;父类型的引用变量&gt;；"></a>向下转型：&lt;子类型&gt;&lt;引用变量名&gt;=（&lt;子类型&gt;）&lt;父类型的引用变量&gt;；</h3><p>运算符：instanceof 进行类型的判断</p><p>Try-catch-finally 如果try中的所有语句正常执行完毕那么finally块就会被执行</p><p>多重catch 一段代码会出现多种异常这时可以在try语句后写多个catch语句块</p><h2 id="第六章：抽象"><a href="#第六章：抽象" class="headerlink" title="第六章：抽象"></a>第六章：抽象</h2><p>概念：如果一个类没有足够的信息去描述一个具体的对象那我们就称之为抽象类</p><p>语法：public abstract class类名{}</p><p>作用：抽象类是用来继承的比普通类更通用</p><p>抽象方法：abstract修饰没有方法体之声明返回的数据类型 方法名称和所需要的参数</p><p>语法 ：public abstract 返回值类型 方法名（参数列表）；</p><p>注意事项：包含抽象方法的类一定是抽象类 抽象类中不一定都是抽象方法 构造方法不能生命为抽象方法 abstract不能与private static final native 并列修饰同一个方法</p><p>Final 修饰类 被final修饰过的类不能被继承 因为不能被继承所以此类中所有方法都是final修饰 该类如果不需要有子类不需要被扩展类的方法不允许被重写就用final修饰该类</p><p>Throws通过try-catch捕获处理异常</p><h2 id="第七章：接口"><a href="#第七章：接口" class="headerlink" title="第七章：接口"></a>第七章：接口</h2><p>概述：在软件中接口是一种规范和标准他们可以约束类的行为是一些方法特征的集合但是没有方法的实现</p><p>语法：</p><p>【修饰符】interface接口名extends父接口1，父接口2……{//常量定义//方法定义}</p><p>Class类名extends父类名implements接口1，接口2….{//类成员}</p><p>Run（）；方法提供服务</p><p>接口是一种能力接口是一种约定</p><p>抛出异常：throw 除系统自动抛出异常可以用throw自动抛出异常</p><p>Throw在程序中抛出异常throws在方法内抛出异常</p><p>第八章：集合框架</p><p>集合框架使用方便的接口和类都在java.util包中</p><p>集合框架的特点：</p><p>长度 数组长度是固定的集合长度是可变的</p><p>存储对象 数组可以存储基本的数据类型，也可以存储对象的引用 集合只能用于存储对象的引用</p><p>对象类型 数组必须是相同类型的数据 对象可以是不同类型</p><p>接口区别：</p><p>Collection接口存储组 不唯一(允许重复)、 无序的对象。<br>Set接口继承Collection接口，存储-组唯一(不允许重复)、 无序的对象。<br>List接口继承Collection接口，存储组不唯-(允许重复)、 有序(以元素插入的次序来放置无素，不会重新排列)的对象<br>Map接口存储组成对的键 值对象，提供key(键)到value(值)的映射。Map中的key不要求有序，不允许重复。value 同样不要求有序，但允许重复。</p><p>List接口：</p><p>实现List接口的常用类有ArayList和Lnkedist.它们都可以容纳所有类型的对象，包括nll允许重复，并且都保证元素的存储顺序。<br>ArrayList和LinkedList的大致区别:<br>arraylist是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构对于随机访问get和set, ArrayList 优于LinkedList, 因为LinkedList要移动指针。<br>对于新增和删除操作add和remove, LinkedList 比较占优势，因为ArrayList要移动数据。</p><p>list接口定义中的格各种常用方法</p><p>boolean add(Object o)在列表末尾顺序添加元素，起始索引位置从0开始<br>int size()返回列表中的元素个数<br>void add(int index,Objecto)在指定的索 引位置添加元素，原索引位置及其后面的元素依次后移<br>注意:新添加元素的索引位置必须介于0和列表中元素个数之间</p><p>0bject get(int index)返回指定索引位置处的元素<br>注意:取出的元素是Object类型，使用前需要进行强制类型转换<br>boolean contains(Object o)判断列表中是否存在指定元素<br>boolean remove(Object o)从列表中删除元素<br>Object remove(int index)从列表中删除指定位置元素，起始索引位置从0开始</p><p>Linkedlist的一些特殊用法<br>void addFirst(Object o)在列表的首部添加元素<br>void addLast(Object o)在列表的末尾添加元素<br>Object getFirst( )返回列表中的第一” 个元素<br>Object getLast( )返回列表中的最后一个元素<br>Object removeFirst( )删除并返回列表中的第一个元素</p><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Hashset的优点就是各方面都很快但数据是无序的</p><p>Threeset优点是有序而且可以按照升序方式进行排序，但是其他各方面不突出</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Object put （object key，object value）以“键一值对”的方式进行存储<br>如果武图添加重复的<br>键，那么最后加入的“键-值对”将替换掉原先的“键一道<br>对”<br>Object get (Object key)根据键返回相关联的值，若不存在指定的键，则返回null</p><p>Object remove (Object key)删除指定的键映射的“键一值对”<br>int size()返回元素个数<br>Set keySet()返回键的集合<br>Collection values( )返回值的集合<br>boolean containsKey (Object key)若存在指定的键映射的“键值对”，则返回true<br>boolean isEmpty( )若不存在键一值映射关系，则返回true<br>void clear()从此映射中移除所有映射关系<br>泛型集合：list ArrayList</p><p>ArrayL ist&lt;0bject&gt; list=new ArrayL ist&lt;0bject&gt;() ;</p><p>list. add (0);</p><p>list. add(99.9);</p><p>list. add(false);</p><p>使用泛型集合在创建集合对象时指定集合中元素的类型，从集合中取出元素时无须进行类型强制转换，并且如果把非指定类型对象放入集合，会出现编译错误。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
</search>
